# 5주차 - 정규화

# 1. 정규화

: 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스

### 📕 [기본] 정규화의 목적과 중요성 알아보기

- **데이터 중복 최소화**: 동일한 데이터가 여러 곳에 저장되지 않도록 합니다.
- **데이터 무결성 유지**: 데이터의 정확성과 일관성을 유지합니다.
- **데이터베이스 구조의 유연성 증가**: 데이터 구조가 변경될 때, 영향을 최소화합니다.

### 📕 [기본] 정규화의 종류 알아보기 (1NF, 2NF, 3NF, BCNF)

1. **제1정규형 (1NF)**: 모든 열의 값이 원자값(atomic value)이어야 합니다. 즉, 각 열은 더 이상 분해할 수 없는 단일 값을 가져야 합니다.
2. **제2정규형 (2NF)**: 1NF를 만족하면서, 기본키의 일부에만 종속된 속성(부분 종속성)을 제거해야 합니다. 즉, 모든 비기본키 속성이 기본키 전체에 완전 종속되어야 합니다.
3. **제3정규형 (3NF)**: 2NF를 만족하면서, 기본키에 비추어 비기본키 속성 간의 이행적 종속성을 제거해야 합니다. 즉, 비기본키 속성이 다른 비기본키 속성에 종속되지 않아야 합니다.
4. **보이스-코드 정규형 (BCNF)**: 3NF를 만족하면서, 모든 결정자가 후보 키이어야 합니다. 즉, 모든 함수적 종속에서 결정자가 후보 키여야 합니다.

![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20-%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B2%E1%84%92%E1%85%AA%20e916c9b7289346dfac894ec7bd0d9380/Untitled.png)

### 📕 [기본] 반정규화 알아보기

정규화는 데이터 조회(select) 시에 조인(join)을 유발하기 때문에 CPU와 메모리를 많이 사용합니다. **반정규화**(denormalization)는 성능 향상을 위해 데이터의 중복을 허용하고 추가 테이블을 도입하는 방식입니다.

### 📕 [기본] 외래키(FK)와 연관 관계

- **외래키(Foreign Key; FK)**
    - 📕 [기본] 외래키(FK) 의 정의와 역할
    
    **외래 키**는 한 테이블의 열(column) 또는 열들의 집합으로, 다른 테이블의 기본 키(primary key)와 연결됩니다. 외래 키는 두 테이블 간의 관계를 정의하고, 데이터 무결성을 유지하는 데 중요한 역할을 합니다. 외래 키의 주요 기능은 다음과 같습니다:
    
    1. **참조 무결성 유지**: 외래 키는 참조하는 테이블의 기본 키 값을 참조해야 하므로, 데이터의 무결성을 유지할 수 있습니다. 즉, 참조되는 값이 존재하지 않으면 데이터베이스는 오류를 발생시킵니다.
    2. **관계 설정**: 외래 키는 두 테이블 간의 관계를 설정합니다. 예를 들어, **`학생`** 테이블과 **`수강`** 테이블 간의 관계에서, **`수강`** 테이블의 외래 키는 **`학생`** 테이블의 기본 키를 참조하여 학생과 수강 정보를 연결합니다.
    
    예시:
    
    ![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20-%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B2%E1%84%92%E1%85%AA%20e916c9b7289346dfac894ec7bd0d9380/Untitled%201.png)
    
    ```sql
    CREATE TABLE Customers (
      id INT,
      first_name VARCHAR(40),
      last_name VARCHAR(40),
      age INT,
      country VARCHAR(10),
      CONSTRAINT CustomersPK PRIMARY KEY (id)
    );
    
    ```
    
    ```sql
    CREATE TABLE Orders (
      order_id INT,
      item VARCHAR(40),
      amount INT,
      customer_id INT REFERENCES Customers(id),
      CONSTRAINT OrdersPK PRIMARY KEY (order_id)
    );
    
    ```
    
    여기서 **`Orders`** 테이블의 **`customer_id`** 열은 **`Customers`** 테이블의 **`id`** 열을 외래 키로 참조합니다.
    
    - 📕 [기본] 외래키 설정 방법 및 주의점
    
    ### **외래 키 설정 방법**
    
    외래 키는 테이블을 생성하거나 기존 테이블을 수정하여 설정할 수 있습니다. 아래는 두 가지 방법을 설명합니다.
    
    1. **테이블 생성 시 외래 키 설정**:
        
        ```sql
        CREATE TABLE Parent (
            ParentID INT PRIMARY KEY,
            Name VARCHAR(100)
        );
        
        CREATE TABLE Child (
            ChildID INT PRIMARY KEY,
            ParentID INT,
            Name VARCHAR(100),
            FOREIGN KEY (ParentID) REFERENCES Parent(ParentID)
        );
        
        ```
        
    2. **기존 테이블에 외래 키 추가**:
        
        ```sql
        ALTER TABLE Child
        ADD CONSTRAINT fk_parent
        FOREIGN KEY (ParentID) REFERENCES Parent(ParentID);
        
        ```
        
    
    ### **외래 키 설정 시 주의점**
    
    1. **참조 무결성 유지**:
        - 외래 키가 참조하는 값은 참조 테이블에 존재해야 합니다. 참조되는 테이블에 없는 값을 외래 키로 설정하려고 하면 오류가 발생합니다.
        - 예를 들어, **`Child`** 테이블에 **`ParentID`** 값으로 존재하지 않는 **`ParentID`**를 삽입하려고 하면 오류가 발생합니다.
    2. **데이터 타입 일치**:
        - 외래 키와 참조하는 기본 키의 데이터 타입은 동일해야 합니다. 예를 들어, **`ParentID`**가 **`INT`** 타입이라면, 외래 키로 설정된 **`ParentID`**도 **`INT`** 타입이어야 합니다.
    3. **인덱스 사용**:
        - 외래 키가 자주 사용되는 경우, 성능을 향상시키기 위해 인덱스를 사용하는 것이 좋습니다. 대부분의 데이터베이스 시스템은 외래 키 열에 자동으로 인덱스를 생성합니다.
    4. **참조 작업의 성능 영향**:
        - 외래 키 제약 조건은 삽입, 업데이트, 삭제 시 참조 무결성을 확인해야 하므로, 성능에 영향을 미칠 수 있습니다. 대규모 트랜잭션이나 일괄 처리를 할 때 성능 문제를 주의해야 합니다.
    5. **삭제 및 업데이트 규칙**:
        - 외래 키 설정 시 삭제 및 업데이트 규칙을 정의할 수 있습니다. 일반적인 규칙으로는 **`CASCADE`**, **`SET NULL`**, **`RESTRICT`** 등이 있습니다.
            - **`CASCADE`**: 참조되는 행이 삭제 또는 업데이트될 때, 참조하는 행도 같이 삭제 또는 업데이트됩니다.
            - **`SET NULL`**: 참조되는 행이 삭제 또는 업데이트될 때, 참조하는 외래 키 값을 NULL로 설정합니다.
            - **`RESTRICT`**: 참조되는 행이 삭제 또는 업데이트될 때, 이를 막고 오류를 발생시킵니다.
        
        예시:
        
        ```sql
        sql코드 복사
        CREATE TABLE Child (
            ChildID INT PRIMARY KEY,
            ParentID INT,
            Name VARCHAR(100),
            FOREIGN KEY (ParentID) REFERENCES Parent(ParentID) ON DELETE CASCADE ON UPDATE CASCADE
        );
        
        ```
        
    6. **순환 참조 피하기**:
        - 두 테이블이 서로를 외래 키로 참조하는 순환 참조 관계는 피하는 것이 좋습니다. 이는 데이터베이스 설계를 복잡하게 만들고 데이터 무결성 문제를 야기할 수 있습니다.
    7. **외래 키 이름 명시**:
        - 외래 키 제약 조건에 이름을 명시하여, 오류 메시지나 디버깅 시 도움이 될 수 있습니다.
        
        ```sql
        sql코드 복사
        CREATE TABLE Child (
            ChildID INT PRIMARY KEY,
            ParentID INT,
            Name VARCHAR(100),
            CONSTRAINT fk_parent_child FOREIGN KEY (ParentID) REFERENCES Parent(ParentID)
        );
        
        ```
        
- **연관 관계**
    - 📕 [기본] 일대일(1 : 1), 다대일(N : 1), 다대다(N : M) 관계의 이해
    
    **연관 관계**는 데이터베이스 내에서 두 개 이상의 테이블 간의 논리적인 연결을 나타냅니다. 연관 관계는 크게 세 가지 유형으로 분류됩니다:
    
    1. **일대일 관계 (One-to-One)**: 한 테이블의 행이 다른 테이블의 행과 정확히 하나의 관계를 갖습니다. 예를 들어, 사람과 여권 관계는 일대일 관계입니다.
        - 예시: **`Person`** 테이블과 **`Passport`** 테이블에서, 각 사람은 하나의 여권을 가질 수 있습니다.
    2. **다대일 관계 (Many-To-One)**: 다수(Many)의 입장이 연관 관계의 주인이 됩니다.
    
    ![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20-%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B2%E1%84%92%E1%85%AA%20e916c9b7289346dfac894ec7bd0d9380/Untitled%202.png)
    
    1. **다대다 관계 (Many-to-Many)**: 한 테이블의 여러 행이 다른 테이블의 여러 행과 관계를 갖습니다. 연결 테이블을 사용하여 일대다, 다대일 관계로 풀어냅니다. 예를 들어, 학생과 강의 관계는 다대다 관계입니다.
        - 예시: **`Student`** 테이블과 **`Course`** 테이블에서, 각 학생은 여러 강의를 들을 수 있고, 각 강의는 여러 학생이 들을 수 있습니다. 이를 연결하기 위해 **`Enrollment`** 테이블을 사용합니다.
    
    예시:
    
    ```sql
    sql코드 복사
    CREATE TABLE Students (
        StudentID INT PRIMARY KEY,
        Name VARCHAR(100)
    );
    
    CREATE TABLE Courses (
        CourseID INT PRIMARY KEY,
        CourseName VARCHAR(100)
    );
    
    CREATE TABLE Enrollments (
        EnrollmentID INT PRIMARY KEY,
        StudentID INT,
        CourseID INT,
        FOREIGN KEY (StudentID) REFERENCES Students(StudentID),
        FOREIGN KEY (CourseID) REFERENCES Courses(CourseID)
    );
    
    ```
    
    여기서 **`Enrollments`** 테이블은 **`Students`**와 **`Courses`** 간의 다대다 관계를 표현합니다.
    
    ![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20-%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B2%E1%84%92%E1%85%AA%20e916c9b7289346dfac894ec7bd0d9380/Untitled%203.png)
    
    ![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20-%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B2%E1%84%92%E1%85%AA%20e916c9b7289346dfac894ec7bd0d9380/Untitled%204.png)
    

### 📕 [기본] CRUD와 조인

- **CRUD 기본**
    - 📕 [기본] 등록(Create), 조회(Read), 수정(Update), 삭제(Delete)의 이해
    
    **CRUD**는 데이터베이스에서 기본적으로 수행되는 네 가지 작업인 등록(Create), 조회(Read), 수정(Update), 삭제(Delete)를 일컫는 말이다.
    
    ![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20-%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B2%E1%84%92%E1%85%AA%20e916c9b7289346dfac894ec7bd0d9380/Untitled%205.png)
    
    1. **등록 (Create)**
        - 새로운 데이터를 데이터베이스에 삽입하는 작업입니다.
        - 데이터베이스에 새로운 레코드를 추가하거나 파일 시스템에 새로운 파일을 생성하는 것과 같은 작업
        - SQL에서 **`INSERT`** 문을 사용합니다.
        - 예시:
            
            ```sql
            INSERT INTO Users (username, email, password) VALUES ('john_doe', 'john@example.com', 'password123');
            
            ```
            
    2. **조회 (Read)**
        - 데이터베이스에서 데이터를 검색하고 읽어오는 작업입니다.
        - SQL에서 **`SELECT`** 문을 사용합니다.
        - 예시:
            
            ```sql
            sql코드 복사
            SELECT username, email FROM Users WHERE username = 'john_doe';
            
            ```
            
    3. **수정 (Update)**
        - 기존 데이터를 수정하는 작업입니다.
        - 데이터베이스에서 기존 레코드를 수정하거나 파일 시스템에서 파일의 내용을 갱신하는 것과 같은 작업
        - SQL에서 **`UPDATE`** 문을 사용합니다.
        - 예시:
            
            ```sql
            sql코드 복사
            UPDATE Users SET email = 'john_doe_new@example.com' WHERE username = 'john_doe';
            
            ```
            
    4. **삭제 (Delete)**
        - 데이터를 데이터베이스에서 삭제하는 작업입니다.
        - 데이터베이스에서 레코드를 삭제하거나 파일 시스템에서 파일을 삭제하는 것과 같은 작업
        - SQL에서 **`DELETE`** 문을 사용합니다.
        - 예시:
            
            ```sql
            sql코드 복사
            DELETE FROM Users WHERE username = 'john_doe';
            
            ```
            
- **조인 기초**
    - 📕 [기본] INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN의 이해
    - 조인은 두 개 이상의 테이블을 결합하여 하나의 결과의 테이블로 만드는 것. 데이터베이스에서 테이블을 분리하여 데이터 중복을 최소화하고 데이터의 일관성 유지하기 위함. 조인의 주요 유형에는 **`INNER JOIN`**, **`LEFT JOIN`**, **`RIGHT JOIN`**, **`FULL JOIN`**이 있습니다.
    1. **INNER JOIN**
        - 두 테이블에서 매칭되는 행만 반환합니다.
        
        ![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20-%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B2%E1%84%92%E1%85%AA%20e916c9b7289346dfac894ec7bd0d9380/Untitled%206.png)
        
        - 예시:
            
            ```sql
            SELECT *
            FROM   테이블1
            INNER JOIN 테이블2
            ON 테이블1.열 = 테이블2.열;
            ```
            
    2. **LEFT JOIN (또는 LEFT OUTER JOIN)**
        - 왼쪽 테이블의 모든 행과, 오른쪽 테이블에서 매칭되는 행을 반환합니다. 매칭되지 않는 오른쪽 테이블의 행은 **`NULL`**로 표시됩니다.
        
        ![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20-%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B2%E1%84%92%E1%85%AA%20e916c9b7289346dfac894ec7bd0d9380/Untitled%207.png)
        
        - 예시:
            
            ```sql
            SELECT *
            FROM 테이블1
            LEFT JOIN 테이블2
            ON 테이블1.열 = 테이블2.열;
            ```
            
    3. **RIGHT JOIN (또는 RIGHT OUTER JOIN)**
        - 오른쪽 테이블의 모든 행과, 왼쪽 테이블에서 매칭되는 행을 반환합니다. 매칭되지 않는 왼쪽 테이블의 행은 **`NULL`**로 표시됩니다.
        
        ![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20-%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B2%E1%84%92%E1%85%AA%20e916c9b7289346dfac894ec7bd0d9380/Untitled%208.png)
        
        - 예시:
            
            ```sql
            SELECT *
            FROM 테이블1
            RIGHT JOIN 테이블2
            ON 테이블1.열 = 테이블2.열;
            ```
            
    4. **FULL JOIN (또는 FULL OUTER JOIN)**
        - 두 테이블의 모든 행을 반환하며, 매칭되지 않는 경우 **`NULL`**로 표시됩니다.
        
        ![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20-%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B2%E1%84%92%E1%85%AA%20e916c9b7289346dfac894ec7bd0d9380/Untitled%209.png)
        
        - 예시:
            
            ```sql
            SELECT *
            FROM 테이블1
            FULL OUTER JOIN 테이블2
            ON 테이블1.열 = 테이블2.열;
            ```
            

[ERD Cloud 가이드라인](https://inpa.tistory.com/entry/ERD-CLOUD-%E2%98%81%EF%B8%8F-ERD-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8%EC%9D%84-%EC%98%A8%EB%9D%BC%EC%9D%B8%EC%97%90%EC%84%9C-%EA%B7%B8%EB%A0%A4%EB%B3%B4%EC%9E%90)

[ERD Cloud 가이드라인](https://inpa.tistory.com/entry/ERD-CLOUD-%E2%98%81%EF%B8%8F-ERD-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8%EC%9D%84-%EC%98%A8%EB%9D%BC%EC%9D%B8%EC%97%90%EC%84%9C-%EA%B7%B8%EB%A0%A4%EB%B3%B4%EC%9E%90)

### 💻 [기본] 게시판 데이터베이스 ERD  만들기 작성해오기

- **작성할 테이블 : `Members(회원)`, `Posts(게시글)`, `Comments(댓글)`**
- 테이블의 속성은 자유입니다.

### 💻 [심화] ERD 실습 : 정규화, 반정규화 적용해보기

- 각 방식을 적용하기 전/후의 상태를 이미지로 올려주시면 됩니다.

### 💻 [기본] 앞서 설계한 ERD에서 쿼리문을 추출해서 MySQL 서버에 적용하기

- 좌측 하단 **`내보내기`** 버튼 클릭 후, **`MySQL`**을 선택
- **`SQL 미리보기`** 를 통하여 CREATE 문 생성

![Untitled](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20-%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B2%E1%84%92%E1%85%AA%20e916c9b7289346dfac894ec7bd0d9380/Untitled%2010.png)

### 💻 [기본] SQL 실습 : 만들어진 데이터베이스에서 CRUD 실습하기

- 실습하면서 사용한 SQL 문과 결과를 작성해주시면 됩니다.

### 💻 [기본] SQL 실습 : 조인(JOIN)으로 조회해보기

- 앞서 만든 데이터베이스에서 **`INNER JOIN`**, **`LEFT JOIN`**, **`RIGHT JOIN`**, **`FULL JOIN`**으로 조회해보기
- 실습하면서 사용한 SQL 문과 결과를 작성해주시면 됩니다.