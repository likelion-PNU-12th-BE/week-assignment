
## **정규화**

### **정규화의 목적과 중요성**

- **목적**: 데이터베이스에서 중복 데이터를 제거하고, 데이터 무결성을 유지하며, **데이터를 효율적으로 관리하기 위해 데이터베이스 구조를 체계적으로 설계하는 과정입니다.**
- **중요성**
    - 데이터 무결성 유지
    - 데이터 중복 감소
    - 데이터베이스의 효율적인 쿼리 성능
    - 데이터 일관성 유지

### **정규화의 종류**

1. **제1정규형 (1NF)**
    - 각 테이블의 컬럼이 **원자값(원자성)**을 갖도록 분해합니다. 즉, 컬럼이 더 이상 쪼갤 수 없는 값을 가지도록 합니다.
2. **제2정규형 (2NF)**
    - 1NF를 만족하면서, 기본 키가 아닌 모든 컬럼이 **기본 키**에 완전 종속되도록 합니다. **부분적 종속성을 제거**합니다.
3. **제3정규형 (3NF)**
    - 2NF를 만족하면서, 기본 키가 아닌 모든 컬럼이 기본 키에 **이행적 종속**이 되지 않도록 합니다.
4. **BCNF (Boyce-Codd 정규형)**
    - 3NF를 만족하면서, 모든 결정자가 후보 키가 되도록 합니다. 즉, 모든 **함수적 종속 관계**에서 결정자가 반드시 후보 키가 되도록 합니다.

### Example

### **제1정규형 (1NF)**

1NF를 만족하려면 **도메인이 원자값**이어야 한다.

- **1NF를 만족하지 않는 릴레이션**
    
    
| 수강과목 | 수강자 |
| --- | --- |
| 수학 | 홍길동 |
| 과학 | 임꺽정, 신사임당 |
| 사회 | 홍길동, 임꺽정 |

| 수강과목 | 수강자1 | 수강자2 | 수강자3 |
| --- | --- | --- | --- |
| 국어 | 홍길동 |  |  |
| 수학 | 신사임당 | 홍길동 |  |
| 영어 | 고길동 | 신사임당 | 홍길동 |

• 수강자 속성이 원자값이 아니다.
• 유사한 속성이 중복, 반복되는 경우도 정규화의 대상이 된다

- **발생할 수 있는 이상(Anomaly)의 예**
    - **갱신 이상**: 홍길동이 사회과목을 '역사'로 바꾸었다. 그럼 임꺽정이 듣고 있는 사회 과목도 바뀌어버린다.
        - UPDATE 과목 SET 수강과목 = '역사' WHERE 수강과목 = '사회' AND 수강자 = '홍길동'
    - **삭제 이상**: 임꺽정이 '과학' 과목을 수강취소했다. 그럼 신사임당의 수강 정보도 삭제된다.
        - DELETE FROM 과목 WHERE 수강과목 = '과학' AND 수강자 = '임꺽정'
- **1NF를 만족시키는 릴레이션**
    
    
| 수강과목 | 수강자 | 일련번호 |
| --- | --- | --- |
| 수학 | 홍길동 | 1 |
| 과학 | 임꺽정 | 2 |
| 과학 | 신사임당 | 3 |
| 사회 | 홍길동 | 4 |
| 사회 | 임꺽정 | 5 |

• 가장 간단한 것은 원자값으로 분해해 튜플로 구분하고 다른 키를 추가하는 것이다.
• 실제로 복잡한 테이블은 이렇게 단순하게 분해해버리면 다른 중복 문제들이 많이 생겨 테이블 구조를 따져봐야한다.

### **제2정규형 (2NF)**

**2NF를 만족하려면 부분적 함수 종속을 제거해야 한다.**

- 즉 완전 함수 종속이 되도록 해야 한다.
- **2NF를 만족하지 않는 릴레이션**
    
    
| 학번 | 이름 | 소속학과 | 학과장 |
| --- | --- | --- | --- |
| 1901 | 홍길동 | 컴퓨터과 | 김교수 |
| 1845 | 임꺽정 | 전자과 | 박교수 |
| 1706 | 신사임당 | 기계과 | 천교수 |
| 1925 | 장영실 | 컴퓨터과 | 김교수 |

• 학번 <-> 이름+소속+학과장은 종속 관계가 있다.(한 학과내의 이름은 중복되지 않는다고 가정)
• 하지만 사실 학과장은 소속학과 하나만에도 종속(소속학과 <-> 학과장)되므로 이는 부분적인 종속관계가 포함되어 있다.
• 즉 학과장은 꼭 이 릴레이션에 있어야 할 필요도 없고, 이 릴레이션에 있는 순간 '김교수'와 같이 계속 중복적재 될것이다.

- **발생할 수 있는 이상(Anomaly)의 예**
    - 삽입 이상: 컴퓨터과, 전자과, 기계과 학생을 추가하고자 할 경우 중복 정보인 학과장 정보가 삽입되어야 한다.
    - 갱신 이상: 컴퓨터과의 학과장이 변경될 경우, 하나만 변경하면 모순이 발생하므로 다 찾아서 변경해야 한다.
    - 삭제 이상: 신사임당이 자퇴해서 삭제하고자 한다. 이 삭제로 인해 기계과 학과장의 정보가 사라져 버린다.
- **2NF를 만족시키는 릴레이션**
    
    
| 학번 | 이름 | 소속학과 |
| --- | --- | --- |
| 1901 | 홍길동 | 컴퓨터과 |
| 1845 | 임꺽정 | 전자과 |
| 1706 | 신사임당 | 기계과 |
| 1925 | 장영실 | 컴퓨터과 |

| 학과 | 학과장 |
| --- | --- |
| 컴퓨터과 | 김교수 |
| 전자과 | 박교수 |
| 기계과 | 천교수 |

### **제3정규형 (3NF)**

**3NF를 만족하려면 이행적 함수 종속을 제거해야 한다.**

- 이행적 함수 종속: A→B 이고 B→C 일 때 A→C 인 관계
- 3NF를 만족하지 않는 릴레이션
    - 소속학과는 특정 대학에 속한다. 즉 대학은 소속학과에 종속된다.
    - 홍길동 → 컴퓨터과이고 컴퓨터과→공대일 때, 홍길동→공대인 관계가 성립한다.
        
        
| 학번 | 이름 | 소속학과 | 대학 |
| --- | --- | --- | --- |
| 1901 | 홍길동 | 컴퓨터과 | 공대 |
| 1845 | 임꺽정 | 전자과 | 공대 |
| 1706 | 신사임당 | 경제 | 경상 |
| 1925 | 장영실 | 경영 | 경상 |
- **발생할 수 있는 이상(Anomaly)의 예**
    - **삽입 이상**: 컴퓨터과, 전자과 학생을 추가하고자 할 경우 더이상 불필요한 중복정보인 대학 정보가 삽입되어야 한다.
    - **갱신 이상**: 컴퓨터과의 소속 대학이 'IT대학'으로 변경되었다. 하나만 변경하면 모순이 발생하므로 다 찾아서 변경해야 한다.
    - **삭제 이상**: 홍길동이 자퇴해서 삭제하고자 한다. 이 삭제로 인해 컴퓨터과의 대학 정보가 사라져 버린다.
- 3NF를 만족시키는 릴레이션
    
    
| 학번 | 이름 | 소속학과 |
| --- | --- | --- |
| 1901 | 홍길동 | 컴퓨터과 |
| 1845 | 임꺽정 | 전자과 |
| 1706 | 신사임당 | 경제 |
| 1925 | 장영실 | 경영 |

| 소속학과 | 대학 |
| --- | --- |
| 컴퓨터과 | 공대 |
| 전자과 | 공대 |
| 경제 | 경상 |
| 경영 | 경상 |

### **BCNF (Boyce-Codd 정규형)**

**BCNF를 만족하려면 결정자이면서 후보 키가 아닌 속성을 제거해야 한다.**

- BCNF를 만족하지 않는 릴레이션

| 학번 | 과목 | 교수 |
| --- | --- | --- |
| 100 | 데이터베이스 | 홍길동 |
| 100 | 자료구조 | 임꺽정 |
| 200 | 네트워크 | 장영실 |
| 300 | 네트워크 | 장영실 |
| 300 | 인공지능 | 유관순 |
- 제약사항
    - 한 학생은 동일한 과목에 대해 한 교수에게만 수강 가능
    - 각 교수는 하나의 과목만 담당
    - 한 과목은 여러 교수가 담당 가능
- 후보 키: (학번, 과목)
- 함수적 종속성
    - (학번, 과목) → 교수
    - 교수 → 과목
- **발생할 수 있는 이상(Anomaly)의 예**
    - **삽입 이상**: 200 학생이 데이터베이스를 수강하고자 할 경우, 현재 불필요한 홍길동 교수 정보가 한번 더 삽입된다.
    - **갱신 이상**: 장영실 교수의 담당 과목이 알고리즘으로 변경되면, 장영실 교수의 과목을 수강하는 모든 학생들의 튜플도 검색해서 수정해야 한다.
    - **삭제 이상**: 300 학생이 자퇴해서 삭제하고자 한다. 이 삭제로 인해 인공지능 과목을 유관순 교수가 담당하고 있다는 정보가 사라진다.
- BCNF 분해 방법
    - 함수적 종속성 Z → X가 있으며 Z가 후보 키가 아닌 경우, (R - X)와 ZX로 릴레이션을 분리
    - 예시. 함수적 종속성 (교수 → 과목)이 있으며, 교수가 후보 키가 아니기 때문에, (학번, 교수), (교수, 과목)으로 분리
- BCNF 분해의 특징
    - 무손실 조인 분해
    - 종속성 유지가 불가능할 수 있음(예시의 경우 함수적 종속성 "(학번, 과목) → 교수"를 유지할 수 없음)
- BCNF를 만족시키는 릴레이션
    - 삽입 이상 해결: 200 학생이 데이터베이스를 수강하기 위해, 홍길동 교수의 정보가 삽입될 필요가 없어진다.
    - 갱신 이상 해결: 장영실 교수의 담당 과목을 변경하기 위해 다른 튜플들을 검색해서 수정할 필요가 없다.
    - 삭제 이상 해결: 300 학생이 자퇴하면, 300 학생의 수강 정보만 삭제하면 된다.

| 학번 | 교수 |
| --- | --- |
| 100 | 홍길동 |
| 100 | 임꺽정 |
| 200 | 장영실 |
| 300 | 장영실 |

| 과목 | 교수 |
| --- | --- |
| 데이터베이스 | 홍길동 |
| 자료구조 | 임꺽정 |
| 네트워크 | 장영실 |

### **반정규화**

반정규화(Denormalization)는 정규화된 데이터베이스를 성능 향상이나 관리의 용이성을 위해 일부러 중복 데이터를 허용하고 정규화된 구조를 일부 되돌리는 작업입니다. 이는 주로 읽기 성능을 높이기 위해 사용됩니다. 반정규화는 데이터 중복을 초래할 수 있지만, 조회 성능이 중요한 경우 유용할 수 있습니다.

- **정의** : 성능 향상이나 기타 이유로 정규화된 데이터베이스를 다시 중복 데이터를 허용하는 형태로 변형하는 과정.
- **목적** : 주로 읽기 성능 향상, 복잡한 조인의 감소, 데이터 접근 속도 개선 등을 위해 사용합니다.

---

## **외래키(FK)와 연관 관계**

### **외래키(FK)의 정의와 역할**

- **정의** : 한 테이블의 필드가 다른 테이블의 기본 키를 참조하는 키입니다.
- **역할**
    - 데이터 무결성 유지
    - 참조 무결성 확보
    - 관계형 데이터베이스에서 테이블 간의 관계를 정의

### **외래키 설정 방법 및 주의점**

- **설정 방법**:

    ```sql
    ALTER TABLE 테이블명
    ADD CONSTRAINT 외래키이름 FOREIGN KEY (컬럼명) REFERENCES 참조테이블(참조컬럼);
    ```

- **주의점**:
    - 참조되는 테이블의 해당 컬럼에 유일한 값이 존재해야 합니다.
    - 외래키가 참조하는 값이 삭제되거나 변경될 경우, 이를 어떻게 처리할지(ON DELETE CASCADE, ON UPDATE CASCADE 등) 설정해야 합니다.

### **연관 관계의 이해**

- **일대일 (1:1)**: 한 테이블의 한 레코드가 다른 테이블의 한 레코드와만 연관되는 관계

    ```java
    CREATE TABLE 사용자 (
        사용자ID INT PRIMARY KEY,
        사용자이름 VARCHAR(100)
    );
    
    CREATE TABLE 사용자프로필 (
        프로필ID INT PRIMARY KEY,
        사용자ID INT **UNIQUE**,
        프로필정보 VARCHAR(255),
        FOREIGN KEY (사용자ID) REFERENCES 사용자(사용자ID)
    );
    ```

- **다대일 (N:1)**: 여러 레코드가 한 테이블의 한 레코드와 연관되는 관계

    ```java
    CREATE TABLE 고객 (
        고객ID INT PRIMARY KEY,
        고객이름 VARCHAR(100)
    );
    
    CREATE TABLE 주문 (
        주문ID INT PRIMARY KEY,
        고객ID INT,
        주문일자 DATE,
        FOREIGN KEY (고객ID) REFERENCES 고객(고객ID)
    );
    ```

- **다대다 (N:M)**: 여러 레코드가 다른 테이블의 여러 레코드와 연관되는 관계. 중간 테이블(교차 테이블)을 통해 구현

    ```java
    CREATE TABLE 학생 (
        학생ID INT PRIMARY KEY,
        학생이름 VARCHAR(100)
    );
    
    CREATE TABLE 과목 (
        과목ID INT PRIMARY KEY,
        과목이름 VARCHAR(100)
    );
    
    CREATE TABLE 수강 (
        학생ID INT,
        과목ID INT,
        PRIMARY KEY (학생ID, 과목ID),
        FOREIGN KEY (학생ID) REFERENCES 학생(학생ID),
        FOREIGN KEY (과목ID) REFERENCES 과목(과목ID)
    );
    ```


## **CRUD와 조인**

### **CRUD 기본**

- **등록(Create)**:

    ```sql
    INSERT INTO 테이블명 (컬럼1, 컬럼2, ...) VALUES (값1, 값2, ...);
    ```

- **조회(Read)**:

    ```sql
    SELECT 컬럼1, 컬럼2, ... FROM 테이블명 WHERE 조건;
    ```

- **수정(Update)**:

    ```sql
    UPDATE 테이블명 SET 컬럼1 = 값1, 컬럼2 = 값2 WHERE 조건;
    ```

- **삭제(Delete)**:

    ```sql
    DELETE FROM 테이블명 WHERE 조건;
    ```


### **조인 기초**

https://velog.io/@wijoonwu/JOIN

- **INNER JOIN**: 두 테이블에서 매칭되는 행만 반환

    ```sql
    SELECT a.컬럼, b.컬럼
    FROM 테이블A a
    INNER JOIN 테이블B b ON a.공통컬럼 = b.공통컬럼;
    ```

- **LEFT JOIN**: 왼쪽 테이블의 모든 행과 매칭되는 오른쪽 테이블의 행을 반환. 매칭되지 않는 오른쪽 테이블의 행은 NULL

    ```sql
    SELECT a.컬럼, b.컬럼
    FROM 테이블A a
    LEFT JOIN 테이블B b ON a.공통컬럼 = b.공통컬럼;
    ```

- **RIGHT JOIN**: 오른쪽 테이블의 모든 행과 매칭되는 왼쪽 테이블의 행을 반환. 매칭되지 않는 왼쪽 테이블의 행은 NULL

    ```sql
    SELECT a.컬럼, b.컬럼
    FROM 테이블A a
    RIGHT JOIN 테이블B b ON a.공통컬럼 = b.공통컬럼;
    ```

- **FULL JOIN**: 양쪽 테이블의 모든 행을 반환. 매칭되지 않는 행은 NULL

    ```sql
    SELECT a.컬럼, b.컬럼
    FROM 테이블A a
    FULL OUTER JOIN 테이블B b ON a.공통컬럼 = b.공통컬럼;
    ```