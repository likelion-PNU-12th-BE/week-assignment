## 데이터베이스

### 📕 [기본] 데이터베이스가 무엇인지 알아보기
구조화된 정보 또는 데이터의 조직화된 모음이며, 일반적으로 컴퓨터 시스템에 전자적으로 저장된 형태.
#### 데이터란?
문자, 숫자, 소리, 그림, 영상, 단어 등의 형태로 된 의미 단위이다.
#### 재해석
구조화된 문자, 숫자 등의 형태로 된 의미 단위의 조직화된 모음.
조직화된 모음은 일정 규칙에 따라 체계적으로 배열됨을 의미한다.
데이터의 조직화된 모음은 데이터가 일정 규칙에 따라 체계적으로 배열된것으로 데이터베이스라 부른다.
### 📕 [기본] 데이터베이스 자료형 알아보기 (MySQL)
1. 숫자형

| 데이터 유형                    | 설명                                                                                                                                             |
|---------------------------|------------------------------------------------------------------------------------------------------------------------------------------------|
| BIT(size)                 | 비트 값 유형. 값 당 비트 수는 size 에 지정됨. size 매개변수는 1 에서 64 까지의 값을 가질 수 있음. size 의 기본값은 1                                                                |
| TINYINT(size)             | 매우 작은 정수. 부호 있는 범위는 -128 에서 127 까지이며, 부호 없는 범위는 0 에서 255 까지임. size 매개변수는 최대 표시 너비(255 까지 가능)를 지정함.                                             |
| BOOL                      | 0 은 거짓으로 간주되고, 0이 아닌 값은 참으로 간주됨                                                                                                                |
| BOOLEAN                   | BOOL 과 동임함.                                                                                                                                    |
| SMALLINT(size)            | 작은 정수. 부호 있는 범위는 -32768 에서 32767 까지 이며, 부호 없는 범위는 0 에서 65535 까지임.(2 바이트) size 매개변수는 최대 표시 너비(255 까지 가능)를 지정                                    |
| MEDIUMINT(size)           | 중간 크기의 정수. 부호 있는 범위는 -8338608 에서 8388607 까지 이며, 부호 없는 범위에서는 0 에서 16777215 까지임.(3 바이트) size 매개변수는 최대 표시 너비(255 까지 가능)를 지정                       |
| INT(size)                 | 중간 크기의 정수. 부호 있는 범위는 -214747648 에서 2147483647 까지이며, 부호 없는 범위는 0 에서 4294967295 까지임. size 매개변수는 최대 표시 너비(255 까지 가능)를 지정                          |
| BIGINT(size)              | 큰 정수. 부호 있는 범위는 -9223372036854775808 에서 9223372036854775807 까지이며, 부호 없는 범위는 0에서 18446744073709551615 임. size 매개변수는 최대 표시 너비(255 까지 가능)를 지정.    |
| FLOAT(size, d)            | 부동 소수점 숫자. 전체 숫자 수는 size 에 지정. 소수점 이하 숫자 수는 d 매개변수에 지정됨. 이 구문은 MySQL 8.0.17 에서 사용되지 않으며, 향후 MySQL 버전에서는 제거될 예정.                                |
| FLOAT(p)                  | 부동 소수점 숫자. MySQL 은 p 값을 사용하여 결과 데이터 유형에 FLOAT 또는 DOUBLE 을 사용할지 결정함. p 가 0 에서 24 사이이면 데이터 유형이 FLOAT()가 됨. p 가 25 에서 53 사이이면 데이터 유형이 DOUBLE 이 됨. |
| DOUBLE(size, d)           | 보통 크기의 부동 소수점 숫자임. 전체 숫자 수는 size 에 지정됨. 소수점 이하 숫자 수는 d 매개변수에 지정.                                                                               |
| DOUBLE PRECISION(size, d) | DOUBLE(size, d)와 동일함.                                                                                                                          |
| DECIMAL(size, d)          | 정확한 고정 소수점 숫자. 전체 숫자 수는 size 에 지정됨. 소수점 이하 숫자 수는 d 매개변수에 지정됨. size 에 대한 최대 숫자는 65 이며, d 에 대한 최대 숫자는 30 임. size 의 기본값은 10 이며, d 의 기본값은 0 임.     |
| DEC(size, d)              | DECIMAL(size, d)와 동일함.                                                                                                                         |



2. 문자형

| 데이터 유형                      | 설명                                                                                                                 |
|-----------------------------|--------------------------------------------------------------------------------------------------------------------|
| CHAR(size)                  | 고정 길이 문자열(문자, 숫자, 특수 문자 포함 가능). size 매개 변수는 문자로 된 열 길이를 지정 0 에서 255 까지 가능. 기본값은 1                                  |
| VARCHAR(size)               | 변경 가능한 길이의 문자열(문자, 숫자, 특수 문자 포함 가능). size 매개 변수는 문자로 된 최대 열 길이를 지정 0 에서 65535까지 가능.                                |
| BINARY(size)                | CHAR()와 동일하지만 이전 바이트 문자열을 저장. size 매개변수는 바이트 단위의 열 길이를 저장. 기본값은 1                                                  |
| VARBINARY(size)             | VARCHAR()와 동일하지만 이진 바이트 문자열을 저장. size 매개변수는 바이트 단위의 최대 열 길이를 지정.                                                   |
| TINYBLOB                    | 대용량 이진 오브젝트(BLOBs)에 사용된다. 최대 길이: 255 바이트                                                                           |
| TINYTEXT                    | 최대 255 문자의 문자열을 저장.                                                                                                |
| TEXT(size)                  | 최대 65,535 바이트의 문자열을 저장.                                                                                            |
| BLOB(size)                  | 대용량 이진 오브젝트(BLOBs)에 사용됨. 최대 65,535 바이트의 데이터를 저장.                                                                   |
| MEDIUMTEXT                  | 최대 16,777,215 문자의 문자열을 저장.                                                                                         |
| MEDIUMBLOB                  | 대용량 이진 오브젝트(BLOBs)에 사용됨. 최대 16,777,215 바이트의 데이터를 저장.                                                               |
| LONGTEXT                    | 최대 4,294,967,295 문자의 문자열을 저장.                                                                                      |
| LONGBLOB                    | 대용량 이진 오브젝트(BLOBs)에 사용됨. 최대 4,294,967,295 바이트의 데이터를 저장.                                                            |
| ENUM(val1, val2, val3,....) | 가능한 값들의 목록에서 선택한 단 하나의 값만 가질 수 있는 문자열 객체. ENUM 목록에 최대 65535 개의 값을 나열 가능. 목록에 없는 값이 삽입되면 빈 값이 삽입됨. 값을 입력한 순서대로 정렬됨. |
| SET(val1, val2, val3,....)  | 가능한 값들의 목록에서 0개 이상의 값을 가질 수 있는 문자열 객체. SET 목록에 최대 64개의 값을 나열할 수 있음.                                                |

3. 날짜형

| 데이터 유형         | 설명                                                                                                                                                                                                                                                                           |
|----------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| DATE           | 날짜. 형식 YYYY-MM-DD. 지원 범위는 '1000-01-01' 부터 '9999-12-31' 까지임.                                                                                                                                                                                                                  |
| DATETIME(fsp)  | 날짜와 시간의 조합. 형식 YYYY-MM-DD hh:mm:ss. 지원 범위는 '1000-01-01 00:00:00' 부터 '9999-12-31 23:59:59' 까지임. 컬럼 정의에 DEFAULT 와 ON UPDATE 를 추가하여 현재 날짜와 시간으로 자동 초기화 및 업데이트가 가능함.                                                                                                             |
| TIMESTAMP(fsp) | 타임스탬프. TIMESTAMP 값은 Unix epoch('1970-01-01 00:00:00' UTC)부터 초 단위로 저장됨. 형식 YYYY-MM-DD hh:mm:ss. 지원 범위는 '1970-01-01 00:00:01' UTC 부터 '2038-01-09 03:14:07' UTC 까지임. 컬럼 정의에 DEFAULT CURRENT_TIMESTAMP 와 ON UPDATE CURRENT_TIMESTAMP 를 사용하여 현재 날짜와 시간으로 자동 초기화 및 업데이트를 지정할 수 있음. |
| TIME(fsp)      | 형식 hh:mm:ss. 지원 범위는 '-838:59:59' 부터 '838:59:59' 까지임.                                                                                                                                                                                                                         |
| YEAR           | 4 자리 수로 표현된 연도. 4 자리 형식에서 혀용되는 값 : 1901 부터 2155, 그리고 0000.                                                                                                                                                                                                                   |

### 📕 [기본] 관계형 데이터베이스가 무엇인지 알아보기 (RDBMS)
**구글 클라우드 피셜**
데이터가 하나 이상의 열과 행의 테이블(도는 '관계')에 저장되어 서로 다른 데이터 구조가 어떻게 관련되어 있는지 쉽게 파악하고 이해할 수 있도록 사전 정의된 관계로 데이터를 구성하는 정보 모음.
```
IBM 예시
회사가 고객 정보를 포함하고 있는 데이터베이스 테이블을 유지 관리하고 있고,
이는 계정 수준에서의 회사 데이터가 포함되어 있습니다.
해당 계정과 관련된 모든 개별 거래를 설명하는 다른 테이블도 있을 수 있습니다. 
이러한 테이블들은 특정 소프트웨어 제품을 구입하는 다른 산업에 대한 정보를 제공할 수 있습니다.

이 고객 테이블의 열(또는 필드)은 고객 ID, 회사 이름, 회사 주소, 산업등이 될 수 있습니다.
거래 테이블의 열은 거래 날짜, 고객 ID, 거래 금액, 결제 방법등이 될 수 있습니다.
테이블은 공통된 고객 ID필드를 사용하여 함꼐 조인될 수 있습니다.
따라서 산업이나 회사별 판매 보고서와 같은 가치 있는 보고서를 생성하기 위해 테이블을 쿼리할 수 있으며, 
이는 잠재적인 고객에 대한 메시징을 결정하는 데 도움이 될 수 있습니다. 
```
#### 트랜젝션
RDBMS 는 일반적으로 명령 또는 트랜잭션을 함께 실행하는 트랜잭션 DB 와 관련이 있다.
주로 사용되는 예는 은행이체가 있다.
정해진 금액이 한 계좌에서 출금되어 다른 계좌에 입금된다. 
전체 금액이 출금되고 입금되며, 이러한 트랜잭션은 어떤 부분적인 형태로도 발생할 수 없다.
여기서 부분적인 형태로 발생할 수 없다는 말은 트랜잭션의 일부분만 실행되지 않고 하나의 형태로만 실행됨을 의미한다.
트랜잭션은 특정한 속서응ㄹ 가지고 있다.
**ACID**약어로 표현되며, 각 속성은 다음과 같다.
- **원자성(Atomicity)** : 모든 데이터 변경 작업은 하나의 단일 작업으로 수행되는 것처럼 수행됨. 모든 변경 사항이 수행되거나 수행되지 않음. = 일부 동작으로 나누어 수행되지 않음.
- **일관성(Consistency)** : 데이터는 시작 상태부터 끝 상태까지 일관된 상태를 유지하여 데이터 무결성을 강화함.
- **격리성(Isolation)** : 트랜잭션의 중간 상태는 다른 트랜잭션에서 보이지 않으며, 결과적으로 동시에 실행되는 트랜잭션은 순차적으로 실행되는 것처럼 보임.
- **지속성(Durability)** : 트랜잭션이 성공적으로 완료된 후, 데이터의 변경 사항은 지속되며 시스템 장애가 발생하더라도 변경 사항이 취소되지 않음.
### 📕 [기본] 비관계형 데이터베이스가 무엇인지 알아보기
일반적인 RDBMS 처럼 행과 열로 이루어진 형식을 사용하지 않는 데이터베이스.
특정 상황에 맞게 최적화된 저장 모델을 사용함.
예를 들면, 키/값 쌍, JSON 문서 또는 그래프가 있음.
장점은 특정 상황에 맞게 제작되었기 때문에 쿼리방법이 구체적이다.
예를 들어 시계열 데이터 저장소는 시간 기반 데이터 시퀀스에 대한 쿼리에 최적화되어 있다.
그러나 그래프 기반 저장소는 엔티티 간의 가중치 관계를 탐색하는 데 최적화되어 있다.

### 📕 [기본] 관계형 vs 비관계형 데이터베이스
#### 구조
RDBMS 는 데이터를 테이블 형식으로 저장함.
그리고 데이터 변경과 테이블 관계가 매우 엄격한 규칙을 따름.
이는 무결성과 일관성을 유지하면서 정형 데이터에 대한 복잡한 쿼리를 처리할 수 있음.

반면 비관계형 데이터베이스는 더 유연하기 때문에 정형 데이터의 요구 사항에 대응하지 못하는 단점을 케어할 수 있음.
그래서 이미지, 비디오, 문서 등과 같은 반정형 및 비정형 데이터를 저장하는데 사용할 수 있음.

## 관계형 데이터베이스(RDB)

### 📕 [기본] 엔티티(Entity)에 대해 알아보기
데이터 표현 대상에 대한 논리적 표현.
현실 세계에서 '사물' 또는 '객체'.
예를 들어 학생, 직원, 은행 등이 엔티티에 해당함.
엔티티 셋은 동일한 속성을 공유하는 유사한 유형의 엔티티 모음이다.
예를 들어 학교의 모든 학생은 학생 엔티티의 집합이 된다.

### 📕 [기본] 테이블(Table)에 대해 알아보기
데이터를 구조화하여 저장하는 기본 단위.
이전의 조직화된 모음과 유사한 의미.
열과 행으로 구성된 2차원 구조를 가지고 있으며, 각 열에는 고유한 데이터 타입이 지정되어 있음.
#### 열
- 테이블에서 한 종류의 데이터를 나타냄. 예를 들어, '이름', '주소','전화번호' 등이 있음.
- 각 열은 고유한 이름과 데이터 타입을 가진다. 데이터 타입은 해당 열에 저장할 수 있는 데이터의 종류와 형식을 결정한다. 예를 들어, 문자열, 정수, 날짜 등이 있음.
- 엔티티의 속성에 해당함
#### 행
- 테이블에서 하나의 데이터 레코드를 나타낸다. 예를 들어, 한 사람의 이름, 주소, 전화번호 등을 한 행에 저장할 수 있다.
- 모든 행은 같은 구조(즉, 열의 구성)를 가지지만, 각각의 행은 고유한 데이터를 저장한다.
- 엔티티의 각 개체에 해당함

#### 튜플(행: Row)가 무엇인지 알아보기
테이블의 각 행을 나타냄.
예를 들어, 고객 테이블이라면 각 행은 서로다른 고객을 나타냄.
#### 어트리뷰트(열: Column)가 무엇인지 알아보기
테이블의 각 열을 나타냄.
예를 들어, 고객 테이블의 고객 ID, 이름, 주소등과 같이 객체의 속성을 의미함.
또한 어트리뷰트는 데이터 타입으로 정의됨.
### 📕 [기본] 기본키(PK)에 대해 알아보기
테이블에서 각 행을 고유하게 식별하는 역할을 하는 컬럼.
즉, 해당 컬럼은 중복된 값이 존재하지 않고, null 값을 가질 수 없다.
참고로 테이블을 생성할 때는 기본키 설정은 없어도 된다.

기본키의 특성은 다음과 같다.
- **고유성** : 기본키로 지정된 속성의 값은 테이블 내에서 중복될 수 없으며, 각 튜플을 유일하게 식별한다.
- **불변성** : 일단 기본키로 지정된 후에는, 가능한 한 그 값이 변경되어서는 안된다.
- **최소성** : 기본키는 테이블을 유일하게 식별하기 위해 필요한 최소한의 속성으로 구성되어야 한다.

## 데이터베이스 명령어

### 📕 [기본] DDL 이 무엇인지 알아보기
#### `CREATE` 질의어 이해하기
#### `DROP` 질의어 이해하기
### 📕 [기본] DML 이 무엇인지 알아보기
#### `SELECT` 질의어 이해하기
#### `INSERT` 질의어 이해하기
#### `UPDATE` 질의어 이해하기
#### `DELETE` 질의어 이해하기
### 📕 [기본] DCL 이 무엇인지 진~~짜 가볍게 알아보기
### 📕 [기본] `COMMIT`, `ROLLBACK` 이 무엇인지 진~~짜 가볍게 알아보기

## 명령어 실습 (docker mysql)
1. 일반 서버 접속

mysql 서버를 docker 에 올렸기 때문에 도커에 접속합니다.
```
docker run -it mysql /bin/bash
```
2. mysql 서버 접속

mysql 서버에 접속합니다.
아래 명령어를 실행한 후 비밀번호를 입력합니다.
```
mysql -u root -p
```
3. 데이터베이스 확인하기

테이블은 데이터베이스 위에 올라가기 때문에 어떤 데이터베이스가 있는지 확인해봅니다.
```
show databases;
```
위 명령어를 입력하면 다음과 같은 결과가 나옵니다.
```
+----------------------+
| Database             |
+----------------------+
| information_schema   |
| mysql                |
| performance_schema   |
| sys                  |
+----------------------+
4 rows in set (0.02 sec)
```
mysql 서버의 환경설정정보를 저장하고 있는 데이터베이스를 확인할 수 있습니다.
아래줄에는 결과요약과 처리 시간을 보여줍니다.

4. 데이터베이스 생성하기

테이블을 올릴 데이터 베이스를 생성합니다.
```
mysql> create database likeliondb;
Query OK, 1 row affected (0.29 sec)

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| likeliondb         |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.01 sec)
```
`likelion` 이라는 데이터베이스가 생성됨을 확인할 수 있습니다.

5. 테이블 생성하기

이제 `테이블을 생성할 데이터베이스를 선택`하고, 테이블을 생성해봅시다.
```
mysql> use likeliondb;
Database changed

mysql> create table Users (
    -> id varchar(10) primary key,
    -> name varchar(10) not null);
Query OK, 0 rows affected (1.60 sec)

mysql> show tables;
+----------------------+
| Tables_in_likeliondb |
+----------------------+
| Users                |
+----------------------+
1 row in set (0.01 sec)
```
Users 테이블이 생성됨을 확인했다.

6. 데이터 삽입하기

테이블에 데이터를 넣어보자.
```
mysql> insert into Users (id,name) values ('1', 'hello');
Query OK, 1 row affected (0.24 sec)

mysql> select * from Users;
+----+-------+
| id | name  |
+----+-------+
| 1  | hello |
+----+-------+
1 row in set (0.00 sec)
```
데이터가 삽입됨을 알 수 있다.
PK 를 적용했으므로 중복 id가 거부되는지 확인해보자.

```
mysql> insert into Users (id,name) values ('1', 'hello');
ERROR 1062 (23000): Duplicate entry '1' for key 'users.PRIMARY'
```
PK 등록이기 때문에 겹치지 못함을 확인했다.

7. WHERE 절 확인하기

where 절은 조건에 따라 조회하므로 id 를 기반으로 존재하는 데이터인지 확인해보자.
```
mysql> select * from Users where id='1';
+----+-------+
| id | name  |
+----+-------+
| 1  | hello |
+----+-------+
1 row in set (0.00 sec)

mysql> select * from Users where id='2';
Empty set (0.00 sec)
```

8. UPDATE 사용해서 수정하기


```
mysql> update Users
-> set id='2'
-> where id='1';
Query OK, 1 row affected (0.62 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from Users where id='2';
+----+-------+
| id | name  |
+----+-------+
| 2  | hello |
+----+-------+
1 row in set (0.00 sec)
```
id 가 1 에서 2 로 변경됨을 알 수 있다.

9. DELETE 사용해서 제거하기

```
mysql> delete from Users where id='2';
Query OK, 1 row affected (0.27 sec)

mysql> select * from Users;
Empty set (0.00 sec)
```
데이터가 삭제됨을 확인할 수 있었음.