## SQL Mapper 와 ORM

### SQL Mapper 의 장단점 알아보기

- 📕 [기본] SQL Mapper 에 대해서 알아보기

직접 작성한 SQL 문의 결과와 객체 필드를 매핑하여 데이터를 객체화 해주는 프레임 워크
DBMS 에 따라 문법이 달라서 종속성의 문제가 있음, 이는 변화에 유연하게 대처하기 어려움
쿼리문과 비즈니스 로직이 분리되어 있기에 유지보수가 편함

### 📕 [기본] JDBC 의 장단점 알아보기

💡 SQL 작성 방식의 이점과 문제점을 알아보시면 좋아요
프로그램과 데이터 베이스를 연결해서 사용할 때 쓰임

#### 장점

SQL 쿼리를 직접 작성해서 세밀한 제어가 가능하다.
다양한 데이터베이스를 지원함

#### 단점

SQL 쿼리와 결과, 예외 처리등의 모든 로직을 작성하면 관리용이성과 개발속도에 악영향
컴파일 과정에서 에러를 발견할 수 없음

### 📕 [심화] Mybatis 의 장단점 알아보기

JDBC 를 단순화 한 것
SQL 을 xml 파일에 저장해서 사용하므로 코드와 SQL 분리함

#### 장점

코드에서 SQL 을 고려하지 않아도 됨
복잡한 쿼리를 세밀하게 처리할 수 있음

#### 단점

xml 도 결국 관리영역
이 기술을 익히는 것의 상대적 비용이 큼
컴파일 에러를 잡을 수 없음

## ORM 의 장단점 알아보기

### 📕 [기본] ORM 에 대해서 알아보기

객체와 DB 테이블을 매핑하는 기술
CRUD 관련 메소드를 지원하기 때문에 반복적인 SQL 작성이 필요 없음
DBMS 종속적이지 않음
복잡한 동작은 JPQL 이나 SQL Mapper 를 활용하면 됨

### 📕 [기본] SQL Mapper 와 ORM 의 차이점 알아보기

SQL 쿼리에 대한 제어를 직접 정의할 수 있기 때문에 성능 최적화가 가능함
특정 DBMS 고유 기능을 사용할 때 좋음

객체 지향적으로 데이터를 관리할 수 있기 때문에, 비즈니스 로직에 더 집중할 수 있음
데이터베이스와 독립적으로 개발이 가능해지며, 객체 지향 특성인 코드 재사용성과 유지보수성이 높다

자바 애플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 API
ORM 을 위한 API 표준이며, 개발자가 데이터베이스와 상호작용이 쉽도록 함
클래스로의 구현이 아닌 인터페이스로의 명세이며, Hibernate 는 JPA 를 구현한 예시임

## 영속화(Persistence)

### 📕 [기본] 트랜잭션에 대해서 알아보기

데이터베이스의 상태를 변화시키는 하나의 작업 단위
여러개의 연산을 포함할 수 있으므로 모두 성공하거나, 하나라도 실패하면 취소(롤백) 됨

### 📕 [기본] 영속화에 대해서 알아보기

웹 애플리케이션이 동작하는 동안 데이터베이스와 통신하고, 그 과정에서 데이터 유지가 필요한 경우가 있다.
데이터가 프로그램이 종료되어도 사라지지 않고 저장되어 있는 것을 영속성이라 한다.
객체를 DB 로 저장하고, DB 의 정보를 객체로 사용하도록 해야한다.

### 영속선 컨텍스트

엔티티를 영구 저장하는 환경
EntityManager 를 통해서 컨텍스트에 접근하며 엔티티의 생명주기를 관리함
컨텍스트는 저장되면 영속 상태가 되며 엔티티와 동일성을 보장하고, 재사용, 변경 감지, 지연 로딩의 작업을 가능하게 함

영속성 컨텍스트 내부에 있는 캐시
한 트랜잭션 범위 안에서만 엔티티를 저장하고 관리함
엔티티 매니저를 통해 조회나 저장 작업을 수행할 때, 먼저 확인해서 성능을 향상 시킴

트랜잭션이 커밋되는 시점에 영속성 컨텍스트는 변경 감지를 수행해서 변경점을 찾고 데이터베이스에 반영함
이후는 데이터베이스에 커밋되어 데이터가 저장됨
과정에서 실패하거나 롤백 호출이 되면, 변경 사항이 취소됨

## Spring Data JPA

### 📕 [기본] JPA 와 Spring Data JPA 의 차이점 알아보기

Spring Data JPA 는 기존 Java 에서 사용하던 JPA 를 Spring 환경에서 보다 더 편리하게 사용할 수 있게 도와주는 프레임워크

#### @Repository 어노테이션

- 이전에 @Bean 또는 @Component 로 객체를 빈 컨테이너에 등록했었다.
- 그런데, @Repository 는 @Component 어노테이션을 가지고 있지 않다.
- 이는 Spring Data JPA 의 어노테이션이기 때문에 다른 어노테이션과 분리되어 있기 때문도 있지만
- 정확한 이유는 @EnableJpaRepositories 어노테이션에서 @JpaRepositoriesRegistrar 를 Import 하고
- @JpaRepositoriesRegistrar 는 ImportBeanDefinitionRegistrar 를 상속받아 구현한다.
- 이때 구현되는 내용에서 JpaRepository 를 빈으로 등록하게 된다.

- 📕 [기본] JPA 애노테이션 알아보기
    - 💡`@Entity` 애노테이션 알아보기
    - jpa 측면에서의 테이블과 매핑하는 어노테이션
    - `@Table` 어노테이션은 DB 와의 매핑을 설정하는 어노테이션
        - 📕[심화] `@NoArgsConstructor` 가 왜 필요한지 알아보기
            - 이 어노테이션은 파라미터가 없는 생성자를 만들어준다.
            - 이렇게 되면 프레임워크가 리플렉션을 통해 엔티티 객체를 생성할 수 있게 해준다.
    - 💡`@Id`, `@GeneratedValue` 애노테이션 알아보기
        - `@Id` 어노테이션
            - 엔티티 클래스의 기본 키 필드에 적용함
            - JPA 기반 엔티티는 무조건 PK 필드를 가짐 (MySQL 에서는 PK 없는 테이블을 생성할 수 있음)
        - `@GeneratedValue`
            - 기본 키 값을 자동으로 생성해주는 전략을 설정함
            - 기본적으로 auto, identity, sequence, table 등이 있음
    - 💡`@Column` 애노테이션 알아보기
        - 엔티티 클래스의 필드와 데이터베이스 테이블의 컬럼을 매핑함
        - name, nullable, unique, length, columnDefinition 등의 옵션을 설정할 수 있음
    - 💡`@ManyToOne`, `@OneToOne`애노테이션 알아보기
        - 다대일, 일대일 관계를 정의함
        - 하나 또는 여러개의 엔티티와 하나의 엔티티를 매핑함
        - 다대다 관계는 다대일 관계를 2번 써서 구성함
        - `@JoinColumn` 어노테이션과 함께 쓰임
            - 이 경우 외래키로 인식함
- 📕 [기본] Spring Data JPA 의 기본 제공 메서드 알아보기
    - 💡 `save()`, `saveAll()`, `findById()`, `findAll()` 등 JpaRepository 인터페이스에 정의된 메서드를 확인해보면 좋아요
    - save, saveAll 은 엔티티를 저장하는 메서드로 save 는 하나, saveAll 은 list 형태로 저장함
    - findById, findAll 은 단건 또는 모두 조회하는 기능 findById 는 기본키로 조회하는 메서드

## JPQL

- 📕 [기본] JPQL 이 무엇인지 알아보기
    - Java Persistence Query Language
    - 검색 쿼리에서 용이하게 사용됨
    - DB 의존적이지 않음
        - DB 에 의존적인 쿼리문을 작성하려면 `@Query` 어노테이션에서 native 옵션을 true 로 설정하면 가능
        - 이렇게되면 엔티티에 적용한 어노테이션을 무시하고 value 에 담긴 sql 문을 그대로 실행함 -> soft delete 무시

