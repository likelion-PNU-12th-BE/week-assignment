# week1-assignment

## 1. 네트워크에 대한 이해

### TCP/IP의 동작 이해

#### 동작

1. 도메인 주소를 입력 받음

2. 목적지 IP주소를 찾기 위해 DNS에 질의함

3. 목적지 IP를 얻음

4. 송수신측 TCP 연결함

5. HTTP Request 요청 보냄

6. HTTP Response 응답 받음

TCP/IP는 패킷 통신 방식의 인터넷 프로토콜인 IP와 전송 조절 프로토콜인 TCP로 이뤄져 있다. IP는 패킷 전달 여부를 보증하지 않고, 패킷을 보낸 순서와 받는 순서가 다를 수 있다. TCP는 IP위에서 동작하는 프로토콜로 데이터 전달을 보증하고 보낸 순서대로 받게 해준다.

그러므로 TCP/IP는 송신자가 수신자에게 IP주소를 사용하여 데이터를 전달하고 그 데이터가 제대로 갔는지, 제대로 받았다고 연락은 오는 지에 대한 것이다.

#### 송수신 구조

기본적으로 데이터 송수신은 (분해 - 전송 - 조립)의 과정을 거친다. 

분해는 송신 쪽에서, 조립은 수신 쪽에서 일어난다. 

분해란 계층을 내려가며 데이터가 담기는 과정이기 때문에 Encapsulation, 조립은 반대로 계층을 올라가며 조립된 데이터를 (프레임 -> 패킷) 순으로 꺼내기 때문에 Decapsulatioin이다. 


세그먼트 - 패킷 - 프레임 등 계층에 따라 데이터의 단위가 달라지고 명칭이 달라진다.

데이터를 꺼내는 과정 중 마지막 단계는 수신 측의 소켓의 입출력 버퍼에 각각의 세그먼트가 채워지고, 이 버퍼를 프로세스의 버퍼가 복사하여 read하는 과정이다. 

이때 송신 측에서 수신측의 윈도우 크기가 보낸 데이터보다 커야 전송하기 때문에 수신 측에서 데이터를 천천히 읽어들이면 전송 지연이 발생한다. 

#### TCP/IP의 4계층

application - transport - internet - network access

#### TCP/IP의 특징

- 흐름제어

	- 송신자는 자신이 한 번에 얼마나 보낼 수 있는지, 수신자는 자신이 데이터를 어디까지 받았는지 끊임없이 확인하고, TCP Header 내의 윈도우 크기를 사용해 한 번에 받고, 보낼 수 있는 데이터의 양을 정한다. (윈도우 크기는 3-handshake 때 수신자가 정한다.)

	- 지금까지 받은 데이터 양을 확인하여 송신자에게 ACK를 보낸다.

	- 받은 데이터에 1을 추가하여 ACK를 보낸다. 이전까지는 제대로 도착했고, 그 다음 순서의 데이터를 받을 차례라는 것을 알려준다. 

	- 이 데이터의 순서 번호를 표기한 것이 Sequence Number이다. 

- 혼잡제어


### 3-Hand Shaking에 대한 이해

데이터를 전송하기 전에 클라이언트와 서버가 잘 연결되었는지 확인하는 과정이다. 총 3번의 hand shaking이 있다.

(SYN - SYN+ACK - ACK) 플래그를 서로 주고 받으면서 연결이 잘 됐는지 확인한다.


데이터를 수신하면 잘 수신했다고 ACK 플래그를 보내게 되는데 받은 데이터에 1을 더하여 ACK를 보낸다. 그 의미는 이전의 데이터들이 잘 도착했고 이 순서의 데이터를 받을 차례라는 것을 알려준다.

3-way hand shaking은 세션을 수립하는 과정이며, 목적지와 수신지를 확실히 연결하여 데이터 전송의 신뢰성을 보장하기 위한 절차이다. 

TCP는 신뢰성있고, 연결지향적 프로토콜이기 때문에 확인 절차를 여러 번 거쳐서 속도는 상대적으로 느릴 수 있다.

TCP/IP는 연결을 할 때와 연결을 끊을 때의 Hand Shaking이 다르다. 

연결을 끊을 때는 4-Hand Shaking을 사용한다. (FIN - ACK - FIN - ACK) 플래그를 사용한다.

## URL 구조 파악

URL(Uniform Resource Locator)은 도메인을 포함한 경로이다. 

사용자가 도메인 서버로 접속할 때 프로토콜 타입과 서비스 타입을 통합적으로 적어준 것이라고 볼 수 있다.

크게 6가지 구조로 나뉜다. 

- 프로토콜 (HTTP, HTTPS, FTP, SFTP 등)은 브라우저가 리소스를 요청하기 위해 사용해야 하는 프로토콜이다. 

	- 프로토콜 : 데이터 통신을 원활하게 하기 위해 필요한 통신 규약으로, 웹에서는 브라우저와 서버 간에 데이터를 주고 받기 위한 방식으로 HTTP/HTTPS 프로토콜이 가장 많이 이용된다.

	- HTTPS : 웹 브라우저와 웹 서버가 서로 데이터를 주고 받기 위해 만든 통신 규약이다. HTTP에서 보안이 강화된 버전이다. 

- 도메인 : 도메인은 IP주소를 갖는 서버를 사용자가 쉽게 기억하고 찾을 수 있도록 만들어준 서비스이다. IP 주소를 변환시켜 줄 네임 서버가 필요하다.

	- 최상위 도메인(.com, .net) : 도메인의 목적, 종류, 국가를 나타낸다.

	- 차상위 도메인(www. m.) : 호스트, 서브 도메인으로 불리기도 한다. 보조 도메인으로써 URL로 전송하거나 계정 내의 IP주소나 디렉토리로 포워딩되는 도메인 이름의 확장자이다.

	- 도메인 이름 : 임의로 지정할 수 있는 사이트의 이름이다. 익히 알고 있는 google, naver 등 사용자에게 쉽게 기억될 수 있도록 보통 서비스 명으로 도메인을 지정해서 사용한다.

- 포트 : 포트 번호를 통해 어떤 서버를 이용할 지 결정한다. 프로토콜의 표준 포트를 사용하는 경우 일반적으로 생략되기 때문에 URL에는 기본적으로 포트번호가 생략되어 있다.

- 경로 : 파일의 경로를 가리킨다. 

- 파라미터 : 쿼리 스트링(key=value) 형태로 이루어진다. ?(물음표)뒤에 나열되고, &기호로 구분되어 여러 개가 존재할 수 있다. 

- 프래그먼트 : Hashtag(#), Ancker라고도 부른다. 특정 요소를 지시할 수 있다. 해시태그로 이동을 원하는 요소으 id를 링크로 연결하면, 스크롤 이동 없이 바로 해당 위치로 이동한다. 

## 개발자 도구 정보 파악

웹 사이트를 즉각적으로 수정하고 문제의 원인을 파악하기 좋다.

여러 개의 Tab으로 구성되어 있다. 

- Elements : 개발자 도구를 키면 기본 탭으로 설정되어 있다. 

	- 웹페이지의 구성(DOM)과 CSS(CSSOM)을 알 수 있다. 

	- html을 읽고 자료 구조 생성

	- html 코드를 분석하고 실시간으로 수정할 수 있는 패널이다. 실시간으로 레이아웃과 디자인을 변경할 수 있다. 

	- Styles

		가장 상단부터 CSS 파일이 우선 순위에 따라 나온다.  제일 먼저 뜨는 스타일이 우선 순위가 가장 높다.

		user agent stylesheet 
		- 브라우저의 기본 스타일 값을 의미한다. 브라우저마다 스타일 기본 값이 다르기 때문에 동일하게 화면에 출력하기 위해서는 초기화를 시키고 작업을 시작하는 것이 좋다.
(reset.css, nomalize.css)

- Console : 컴퓨터의 키보드&마우스 같이 동작을 조절하는 패널이다.

	자바스크립트 코드를 즉시 실행할 수 있다. (console.log())로 표현한다.

	프론트엔드와 백엔드에서 활용할 수 있는데 백엔드의 경우는 response(에러 메시지, status 코드)도 console.log를 활용해 확인이 가능하다. 

- Network : 웹사이트에서 통신하고 있는 모든 정보를 목록으로 보여준다. 리소스들이 예상대로 다운로드 되고 업데이트 되는지 확인할 때 사용한다. 웹페이지와 서버 사이에서 데이터 흐름을 분석하고, 문제 발생 시 해결책을 찾도록 개발자를 돕는 역할을 한다. 

	- Network : 패널 안에 다양한 tab들을 통해 모든 네트워크 요청을 볼 수 있다.

	- Name : 리소스의 이름과 URL 표시

	- Status : 작동 여부 표시

	- Type : 파일의 형식

	- Initiator : 요청을 발생시킨 코드 표시

	- Size : 리소스들의 파일 사이즈

	- Time : 요청과 응답까지 걸린 시간 확인

	- Waterfall : 타임라인 세부 정보

- Application : 브라우저 저장소이고, 3개가 있다. 저장소에 뭐가 들었는지 볼 수 있다. 

	- Local Storage : 클라이언트 단

		- 사용자가 지우지 않는 이상 계속 브라우저에 남아있다.

		- 지속적으로 필요한 데이터를 저장한다. (자동 로그인,,) 
*민감한 정보는 클라이언트 단에 저장하지 않는다.(ex.비밀번호)

	- Session Storage : 클라이언트 단

		- 브라우저 종료 전까지만 보존 가능하다.

		- 탭 종료 전까지 남아있다.
	
		- 잠깐 동안 필요한 정보를 저장한다.

	- Cookie : 클라이언트에 저장되지만 서버에서도 응답을 보낼 수 있다.

    		- 저장 용량이 작다.

    		- 무조건 요청 보낼 때 마다 같이 전송된다.

## HTTP 요청, 응답 메시지에 대한 이해

### HTTP의 요청/응답 구조

사용자가 www.naver.com 을 입력하는 경우

1. 사용자가 브라우저에서 URL을 입력한다. (GET)

2. 브라우저가 요청 메시지를 보낸다.

3. 서버가 URL을 프로그램 또는 정적 파일로 연결한다.

    - HTTP 메서드를 이용해서 파일을 찾는다.

4. 서버가 응답 메시지를 반환한다.

    - 바이트 스트림 형태로 반환

    - 인코딩(UTF-8) → HTML

    - 바이트 → 문자화 → 토큰화 → 노드 → DOM(tree 형태)

5. 브라우저가 응답 형식에 맞춰 표시한다.


### HTTP 요청 메시지 구성

공백(blank line)을 제외하고 3가지 부분으로 나뉜다.

- Start Line 시작라인

    - 요청이나 응답 상태를 나타내고, 항상 첫 번째 줄에 위치한다.

    - HTTP method : 요청 의도, 서버가 수행해야 할 동작을 지정한다.

        - 서버에게 전달할 데이터는 쿼리 파라미터를 통해서 전달한다.

    - Request target : 전송 목적지 주소

        - 보통 절대 경로로 ‘/’로 시작하고 쿼리를 합친다.

    - HTTP version : 버전에 따라 요청 메시지 구조나 데이터가 다를 수 있기 때문에 버전 정보를 명시해야 한다.

- Headers 헤더 : Request에 대한 추가 정보를 담고 있다.

    - 헤더의 용도는 HTTP 전송에 필요한 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트 정보, 서버 애플리케이션 정보, 캐시 관리 등 모든 부가 정보가 들어가 있다.

    - 표준 헤더가 많고 필요한 경우에 임의의 헤더도 추가할 수 있다.

- blank line 공백 라인

- Body 메시지 내용 : HTTP Request가 전송하는 데이터를 담고 있는 부분이다. 전송할 데이터가 없으면 body는 비어있다.

### HTTP의 메소드(method)

클라이언트 - 서버 구조에서 요청과 응답이 이루어지는 방식을 의미한다. 

서버가 수행해야 할 동작을 지정하여 요청을 보내는 방법이다.

- **GET** : 리소스를 조회

    - URL 입력이나 링크를 클릭하는 경우에 GET요청에 해당된다.

    - 멱등성이라는 개념이 있어, 여러 번 조회 요청을 해도 리소스는 변하지 않는다.

    - 서버에 데이터를 전송하는 경우 쿼리 스트링을 이용한다. (URL 가장 마지막에 ?를 추가하고 그 이후에 query=미세먼지)

    - 쿼리스트링은 클라이언트에게 전달하는 데이터 정보가 무방비 상태로 노출되므로, 주의해야 한다. 브라우저 히스토리에도 기록이 남는다.

    - 캐싱이 가능하기 때문에 조회할 때, GET 방식이 유리하다.

- **POST** : 데이터 추가, 등록

    - 주로 새로운 리소스를 생성하는데 사용된다.

    - 성공적으로 creation을 완료하면 201 HTTP 응답을 반환한다.

    - 데이터를 메시지 바디에 쿼리 파라미터 형식으로 전달한다.

        - 적용해야 할 데이터가 많을 수 있어 쿼리 파라미터나 쿼리 스트링보다는 주로 메시지 바디를 통해 서버로 요청 데이터를 전달한다.

    - 쿼리 파라미터는 Key-Value 형식으로 되어 있어, 데이터가 외부로 노출되지 않으므로 보안상의 이점이 있다.

    - 데이터를 전송할 때, Body에 담아 전송하므로, 메시지 길이의 제한이 없다. 문자열 데이터 뿐만 아니라 객체들의 값도 전송할 수 있다.

- **PUT** - 리소스 대체, 수정 / 해당 리소스가 없으면 새로 생성

    - 리소스를 완전히 대체하는 개념이다.

    - 부분 수정이 불가능하다. 기존에 A, B라는 데이터가 존재했는데 C를 담아 PUT 요청을 보낸다면 A,B는 모두 삭제되고 C로 대체되는 개념이다.

    - 멱등성을 가진다.

- **DELETE** : 리소스 삭제

    - 리소스를 제거하는 역할이다.

    - 멱등성을 지닌다.

- **PATCH** : 리소스 부분 변경 (수정)

    - PUT과 같이 리소스를 수정하지만 부분 변경을 한다는 점에서 차이가 있다.

    - 기존 데이터 A, B가 존재할 때, B=C로 대체된 후 PATCH 요청을 하면 A, C로 변경된다.

    - 멱등성을 가지지 않는다.

- HEAD : GET과 동일하나, HTTP 메시지의 body 부분을 제외하고 조회

- OPTIONS 

	- 서버와 브라우저가 통신하기 위한 통신 옵션을 확인하기 위함.

	- 서버가 어떤 method, header, content-type을 제공하는지 알 수 있다.

- CONNECT - 대상 자원으로 식별되는 서버에 대한 연결 요청

### HTTP의 특징

단방향성, 비연결성, 무상태성

비연결성 - 연결이 계속 유지되지 않고 요청에 대한 응답이 끝나면 연결을 바로 끊는다. 새로운 요청이 생기면 다시 새로 연결을 해야 한다.

### HTTP Response Message(응답 메시지)

HTTP 응답 메시지는 요청과 동일하게 공백을 제외하고 3가지 부분으로 나뉘어 진다.

- Start Line = Status Line : 응답 상태를 간략하게 나타내주는 부분

    - HTTP version

    - Status Code : 클라이언트가 보낸 요청이 성공했는지 실패했는지 나타내는 상태이다.

    - phrase : 이유 문구 : 사람이 이해할 수 있는 짧은 상태 코드를 읽을 수 있는 글이다.

- Headers

    - content-type : 표현 데이터의 형식 (문자 인코딩, 미디어 타입 등,)

    - content-encoding - 표현 데이터의 압축 방식 (gzip, deflate, identity,,)

        - 송신 측에서 압축 후 인코딩 헤더를 추가하고, 읽는 쪽에서 헤더를 보고 디코딩하여 압축 해제한다.

    - Content-Language : 자연 언어 (한국어, 영어, 일어,,)

    - Content-Length : 표현 데이터의 길이

    - 인증 : 클라이언트 인증 정보를 서버에 전달

    - 쿠키 : 클라이언트가 서버에서 받은 쿠키를 저장하고 HTTP 요청 시 서버로 전달한다.

- Body : 실제 전송할 데이터가 담겨있다. byte로 표현할 수 있는 모든 데이터의 전송이 가능하다.

    - 헤더에 명시되어 있는 정보들에 따라 바디의 데이터가 어떻게 해석되어야 하는지 알 수 있다.

    - 주로 JSON 형식을 사용한다.

        - 데이터를 교환하기 위한 경량의 데이터 형식으로, 주로 웹에서 데이터를 주고 받을 때 많이 사용된다.

        - 사람과 기계가 모두 이해하기 쉽고 읽기 쉬운 형태로 데이터를 표현한다.

### HTTP의 Status Code(응답 코드)

- 1XX : 요청 처리 중이다.

- 2XX : 요청이 정상적으로 이뤄졌다. (OK, Created, Accepted,,

- 3XX : 리다이렉션 요청으로 다른 주소로 이동한다.

- 4XX : 클라이언트 오류로 응답 불가능하다. (Forbidden, Not Found,,)

- 5XX : 서버 오류로 응답 불가능하다. (Internal Server Error, Bad Gatewqy,,)

