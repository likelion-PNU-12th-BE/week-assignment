
# MVC 패턴

MVC패턴은 소프트웨어 설계에 사용되는 "아키텍처 패턴"이다.
mvc 패턴에 따르면 애플케이션은 세 부분(model,view,controller)으로 구분됩니다.
이 구조는 애플리케이션의 데이터처리(Model), 사용자 인터페이스(View), 입력에 대한 처리(Controller)를 분리하여 관리합니다.
이러한 분리를 통하여 유지 보수성을 높이고, 확장성을 확장시킬 수 있습니다.

# Model

Model은 코드 중 애플리케이션의 데이터와 비즈니스 로직을 관리하는 영역입니다.
( = Model에는 데이터를 처리하는 코드가 존재한다.)
데이터베이스, 파일 시스템 또는 외부 서비스와의 데이터 교환을 포함하여 모든 처리를 담당합니다.
모델은 독립적으로 작동되며, 뷰와 컨트롤러와 직접적인 통신하지 않습니다.

모델은 애플리케이션에서 사용되는 객체를 정의한 클래스의 집합입니다.
각 클래스에는 필드와 메서드(+crud연산)를 가진다.
# View

View는 코드 중 사용자에게 정보를 보여주는 인터페이스 영역입니다.
( = View에는 시각적 인터페이스를 구현하는 코드가 존재한다.)
(1) 모델에서 데이터를 받아 사용자에게 표시합니다.
(2) 입력을 컨트롤러에 전달합니다.
# Controller

Controller는 코드 중 사용자 입력을 처리하고 모델과 뷰사이 연결고리 역할을 하는 영역입니다.
( = Controller에는 입력을 해석하고 매개하는 코드가 존재한다.)

# 모델/뷰/컨트롤러는 코드를 기능별로 구분한 것이므로 각각 다른 디렉토리에 담긴다.

# M-V-C의 상호 작용

사용자가 애플리케이션에서 작업을 수행하면, 뷰(View)는 사용자의 입력을 감지하고 컨트롤러(Controller)에 전달합니다.  
**컨트롤러는 사용자 입력을 처리하고 적절한 모델(Model) 기능을 호출**하여 데이터를 검색, 수정 또는 저장합니다.  
**모델은 데이터와 관련된 비즈니스 로직을 수행**하고, **필요한 경우 데이터베이스와 상호 작용**합니다. **모델은 작업이 완료되면 결과를 컨트롤러에 반환**합니다.  
**컨트롤러는 모델의 결과를 받아 뷰에 전달**합니다. 뷰는 이 **데이터를 사용하여 사용자에게 보여지는 화면을 업데이트**합니다.

출처
https://mundol-colynn.tistory.com/147




# 기존의 Spring의 설정 측면에서 단점 알아보기

기존의 Spring은 많은 기능을 제공하는만큼 무거운 프레임워크입니다.

# Spring Boot가 제공하는 장점 알아보기

1. 코드가 상대적으로 단순하다.
2. 애플리케이션 필요에 따라 자동으로 Spring 설정을 해준다.
3. 별도의 웹 서버 설치없이 실행할 수 있다.
4. 의존성 관리가 쉽다.

# 로깅(Logging)이란?

로깅은 애플리케이션의 실행 과정에서 발생하는 이벤트를 기록하는 "행위"입니다.
로깅으로 작성된 로그를 통해 시스템의 상태, 오류 메세지, 정보 메세지를 확인할 수 있다.
로그에 포함된 메세지를 통해 애플리케이션에 대한 정보를 취득하여 적절한 행위를 할 수 있다.

# System.out.println()와 로깅의 차이

우선 로깅은 기록하는 "행위"이고, System.out.println()는 기록하는 "방법"이다.
질문을 좀 더 자세히 규정하자면, "System.out.println()을 사용한 로깅과 별도의 로깅 라이브러리를 사용한 로깅의 차이"이다. 
1. System.out.println()의 휘발성
   System.out.println()은 로그가 표준 출력으로 출력된다. 즉 파일로 저장되지 않는다.
2. System.out.println()은 추적 정보를 남기지않는다
   issue 발생 날짜, 시각, 문제 수준, 위치 정보를 남기지않는다.
   인자로 구현 가능하지만 번거롭다.
3. System.out.println()은 로그 출력 레벨을 사용할 수 없다.
4. System.out.println()은 성능 저하의 원인이 될 수 있다.

출처
https://hudi.blog/do-not-use-system-out-println-for-logging/


# @Slf4j 애노테이션 알아보기

@Slf4j는 Lombok 라이브러리가 제공하는 애노테이션이다.
@Slf4j를 클래스에 적용하면 SLF4J 로거 인스턴스를 자동으로 생성한다.
따라서 개발자는 로거 객체를 별도로 선언하지 않고도 로깅을 수행할 수 있다.

# Spring MVC의 요청 처리 플로우

http 요청 메세지가 도착하면 
서블릿 컨테이너의 필터에서 파싱되어 Dispatcher Servlet에 도착한다.
(Dispatcher Servlet이 최초 진입점으로 볼 수 있다.)
![[Pasted image 20240509100112.png]]
Dispatcher Servlet이 어떻게 요청을 매핑하고 MVC 패턴을 적용하는 지 알아보자
![[Pasted image 20240509100141.png]]
![[Pasted image 20240509100155.png]]
1. (파싱된) http request message가 들어온다.
2. Handler Mapping을 통해 요청에 매핑되는 컨트롤러를 찾는다
3. 찾아낸 컨트롤러를 실행시킬 수 있는 Handler Adapter를 찾는다
4. Handler Adapter를 실행시킨다
   여기서 컨트롤러가 실행되어 서비스 로직이 돌아간다
5. 결과값으로 나온 Model이 생성되고, 선택한 View의 이름을 반환한다.
6. View Resolver를 통해 찾은 view를 오브젝트를 찾고 model과 데이터 바인딩시킨다.
7. 최종적으로 완성된 View를 Dispatcher Servlet이 반환하면, 동적 웹페이지가 완성된다.

# @Controller 어노테이션 알아보기

@Controller
@Controller는 클래스가 스프링 MVC 컨트롤러임을 나타내는 어노테이션입니다.
웹 요청과 응답을 처리하는 메소드들을 포함합니다.
이 어노테이션을 사용하면 클래스 내의 메소드가 ModelAndView 객체나 뷰이름을 문자열로 반환합니다.

@RestController
@RestController는 @Controller에 @ResponseBody를 추가한 어노테이션이다.
이 어노테이션을 사용하면 클래스 내의 모든 메소드가 HTTP 응답 본문에 직접 데이터를 반환합니다.

차이점
1. 목적과 사용처 
   @Controller는 주로 뷰 템플릿을 통해 HTML 페이지 반환에 사용, @RestController는 RESTful API를 개발하여 JSON이나 XML같은 형식으로 데이터를 반환하는데 사용됩니다.
2. 응답방식
   @Controller에서는 ModelAndView 객체나 뷰 이름을 반환하지만 @RestController에서는 메소드의 반환값이 직접 응답 본문으로 사용됩니다.

# @Service 어노테이션 알아보기

@Service 어노테이션은 비즈니스 로직을 처리하는 서비스 레이어의 클래스에 사용됩니다.
주요 사용 목적 : 비즈니스 로직의 처리 및 관리
장점 : 서비스 레이어의 역할을 명확히 하여, 애플리케이션의 유지보수성 및 확장성을 높일 수 있습니다.

# @Repository 어노테이션 알아보기

@Repository 어노테이션은 데이터 액세스 로직을 처리하는 DAO(Data Access Object) 또는 리포지토리레이어의 클래스에 사용됩니다.
주요 사용 목적 : 데이터베이스 또는 다른 저장소로의 데이터 접근 및 조작 로직의 처리 및 관리
장점: 데이터 액세스 로직을 분리하여 관리하므로, 데이터 소스 변경이나 ORM 프레임워크 변경 시 유연한 대처가 가능하며, 예외 처리도 쉬워집니다.