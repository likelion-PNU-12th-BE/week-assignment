# 네트워크

##컴퓨터 네트워크

-데이터와 리소스를 전송, 교환 또는 공유할 목적으로 케이블(유선) 또는 WiFi(무선)를 통해 연결된 두 대 이상의 컴퓨터로 구성
-하드웨어(예: 라우터, 케이블 등)와 소프트웨어(운영 체제 또는 애플리케이션 등)를 사용하여 컴퓨터 네트워크를 구축
-지리적으로 정해지는 경우가 많음
-통신에 사용하는 프로토콜,  트래픽 제어 방법 및 목적 등에 따라 추가로 정의

###네트워크 유형

1. LAN(로컬 영역 네트워크)
-비교적 짧은 거리에서 컴퓨터를 연결하여 데이터, 파일 및 리소스를 공유. 
-ex) 건물 내부의 컴퓨터 간 연결, 학교 또는 병원 내의 모든 컴퓨터를 연결.
-개인이 소유하고 관리합니다.
 
2. WLAN(무선 로컬 영역 네트워크)
- LAN과 비슷하지만, 네트워크 내의 디바이스 간 연결이 무선으로 이루어짐.
																								
3. WAN(광역 네트워크)
-지역 간 또는 대륙 간 등 넓은 지역의 컴퓨터를 연결
-ex) 인터넷
 
4. MAN(대도시 네트워크)
-일반적으로 LAN보다 크지만 WAN보다 작은 규모
-보통 도시와 정부 기관에서 소유하고 관리
 
5. PAN(개인 네트워크)
-한 사람에게 서비스를 제공
-ex) iPhone과 Mac을 사용하는 경우 두 기기에서 문자 메시지, 이메일, 사진 등의 콘텐츠를 공유하고 동기화
 
6. 기타 
-CAN(캠퍼스 네트워크),  SAN(스토리지 영역 네트워크), VPN(가상 사설망)


#TCP/IP

##TCP/IP
-인터넷에서 사용하는 기본 통신 프로토콜로, 100개 이상의 관련된 프로토콜 군을 총칭
-인터넷 프로토콜 스택은 OSI Model, TCP/IP model이 있음
-4계층으로 구성(네트워크 접속, 인터넷, 전송, 응용)

	1. 네트워크 접속
	- 프레임(주고 받는 데이터)의 송수신을 담당.
	- 인터넷 계층의 일부 프로토콜 동작 구간
	- 네트워크에 물리적으로 연결, 통신
	2. 인터넷
	- IP 주소 체계 관리
	- 패킷 수신시 목적지 IP 주소 확인, 패킷을 주소지로 전달(라우팅)
	- IP, ICPM(통신 상태 감시, 유지, 관리), ARP, RARP
	3. 전송
	- TCP(transmission control protocol)
		- 포트 번호 사용 ->프로세스간 신뢰성 있는 통신
	- , UDP(user datagram protocol)
		- 포트 번호 사용 ->프로세스간 신뢰성 보장 할 수 없는 통신
		- 헤더가 TCP보다 단순 -> 통신 데이터 처리 속도 빠름
	4. 응용
	- 데이터를 처리하는 응용프로그램으로 구성
	- 사용자와의 인터페이스 제공
	- HTTP, HTTPS, FTP, SMTP, POP3, DNS 등

##IP의 문제점
	- 신뢰성 없음
		○ 에러제어(전송 중 발생하는 에러 검출, 보정)
		○ 네트워크를 통한 패킷 전달을 완전히 보장(소실,중복,지연,순서역전) 등의 방지
	
	- 흐름제어 기능 없음
		○ 송신측이 수신측의 처리속도 보다 더 빨리 데이터를 보내지 못하도록 제어해 주는 것
	- 이 둘을 합쳐서 최선형 (best-effort service)

	-  비연결성 
		○ 어떠한 사전 호출 / 연결 설정행위 없이도 두 호스트 시스템 간에 데이터를 교환할
		수 있는 방식

##TCP의 특징
	- IP의 비신뢰적 최선형 프로세스 상호간에 신뢰적인 연결지향성 서비스 제공
	- 신뢰성 보장
		○ 패킷 손실, 중복, 순서 바뀜 등이 없도록 보장
	- 연결지향적임
		○ 이 경우, 느슨한 연결(Loosly Connected)을 가짐
			§ 서로 약하게 연결되어 떼어낼 수 있어 한 시스템의 변경이 다른 시스템에 영향을 주지 않음
			§ 서로에 대한 지식이 거의 없어도 사용가능
		○ 연결 관리를 위한 연결설정 및 연결해제 필요 
	- 세그먼트화 처리     
		○ 바이트들을 모아서 세그먼트화하고 이에 TCP 헤더를 붙이고, 이들을 순서 제어함
	        . TCP 세그먼트 : TCP에서 IP로 전달되는 정보 단위(통상, 수 백 바이트 정도)   -
	- 흐름제어                                         
	     - 송신(송신전송률) 및 수신(수신처리율)  속도를 일치시키는 것
###용어
	1. 호스트 
	- 네트워크에 연결되어 다른 호스트들과 통신할 수 있는 컴퓨터 및 장치
	- 서버는 호스트가 맞음, 다만 모든 호스트가 서버는 아님
	2. 패킷 - 네트워크 통신에서 주고받는 데이터 단위 
	- 헤더(머리) + 페이로드(내용/데이터) + 트레일러(꼬리)로 구성
	- 헤더에는 패킷의 주소(송수신 주소) 등 주요 제어 정보들이 포함
	- 트레일러는 패킷 에러 검출 등에 사용되며 없는 경우도 많음
	3. 노드
	-네트워크에서 연결 지점, 다른 노드로의 데이터 전송을 인식하고 처리하거나 전달
	- 물리적인 노드 네트워크에서 정보를 만들고, 통신으로 이를 주고 받을 수 있는 장치(컴퓨터)
	4. 프로토콜 
	- 통신 시스템이 데이터를 교환하기 위해 사용하는 통신 규칙
	5. 프로토콜 슈트 
	- 계층 구조로 이루어진 통신 규약들의 집합. 
	- 신뢰성 있는 통신을 수행하기 위해 통신의 과정을 여러 개의 계층으로 구분하여 차곡차곡 쌓아 놓은 것과 같은 구조로 구성
	- 프로토콜 스택, 프로토콜 패밀리라고도 부름
## 3 way-handshake
	TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 연결함 

	Ack 신호가 유실될 경우 문제 발생
	-> 완벽하게 안전하지는 않음

	1. Client > Server : TCP
	- 클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보냄.
	- 클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태
	
	2. SYNServer > Client : TCP SYN(synchronize : 접속 요청) 
	- 서버는 SYN 요청을 받고 클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송
	- 클라이언트가 다시 ACK으로 응답하기를 대기
	- 서버는 SYN_RECEIVED 상태
	
	3. ACKClient > Server : TCP ACK(acknowledge : 접속 허용)
	- 클라이언트는 서버에게 ACK을 보냄
	- 이후로부터는 연결이 이루어지고 데이터 송수신 가능
	- 서버 상태가 ESTABLISHED

#서버와 클라이언트

	서버
	-데이터를 포함하거나 네트워크의 다른 컴퓨터에서 액세스하는 기능을 제공하는 컴퓨터
	-하드웨어 혹은 소프트웨어
	-웹서버, 네임서버, 메일서버, 인증서버

	클라이언트
	-서버로부터 서비스나 데이터를 요청하는 컴퓨터
	- 웹 브라우저, 데스크톱 프로그램, 모바일 앱, 다른 서버에 요청을 보내는 서버 등

#URL

	방대한 컴퓨터 네트워크에서 자신이 원하는 정보 자원을 찾기 위해서는 해당 정보 자원의 위치와 종류를 정확히 파악할 필요가 있음
	->  이를 나타내는 일련의 규칙을 URL(Uniform Resource Locator: 자원 위치 지정자)

	URL 에는 컴퓨터 네트워크 상에 퍼져 있는 특정 정보 자원의 종류와 위치가 기록되어 있음

	URL != 인터넷 주소
	-> 일반적으로 입력하는 것은 도메인 이름 (naver.com), IP 주소 (222.122.195.6) => 해당 서비스 제공 컴퓨터의 위치이지 특정 정보의 위치가 아님 

	인터넷 도메인 이름이나 IP 주소는 물론, 이메일, 파일 전송과 같이 컴퓨터 네트워크 정보 자원을 이용하는 모든 형태에 적용됨.

##구조
	http://www.ktword.co.kr/test/view/view.php?nav=2&no=867&sh=URL

	프로토콜://호스트명[:포트번호]/[경로][;인자][?질의문자][#]

	 1. 프로토콜(Protocol) 
	- URI Scheme 이라고 하며, 접근 프로토콜을 지시함
	- http, https, file, mailto, ftp 등 
	2. 콜론(:)
	- 2개를 묶은 쌍(pair)에서 좌우 구분을 위한 구분자
	3. 대쉬(//)
	- 어떤 시작을 알리는 것
	- 콜론 뒤에 도메인 이름이나 IP 주소로 이어지는 경우 콜론( : )뒤에 슬래시 2개( // )를 붙임
	4. 호스트명 또는 호스트이름(Host Name) www.ktword.co.kr 등
        	- 호스트명 또는 IP주소
	5. 포트 번호(Port Number)
	- 포트 번호가 생략되면, 프로토콜별 기본 포트번호(Well Known Port)를 사용함
	6. 경로(Path) : /test/ 등
	-  파일 디렉토리는 생략할 수 있으며 이 때는 컴퓨터 관리자가 정한 기본 디렉토리를 의미
	- 임의로 매칭도 가능
	7. 질의문자(Query) 
	- ex) ?id=10&no=10 
	- key와 value 형태로 데이터가 들어가 있다.
	- 검색 용어 등을 지정하는데 쓰임.
	- 복수 개의 key, value가 존재하는 경우 &를 사용
	8.  프래그먼트 or 태그(#) 
	- 웹페이지 내 특정 링크의 앵커(한 페에지 내에 링크를 만드는 기능을 앵커라 한다, ex) 페이지 특정 부분 클릭시 그 위치로 이동)를 지정하는데 사용
	- 잘 사용하지 않고 서버에 전송하는 정보가 아니다.

#http 구조
	HTTP(Hypertext Transfer Protocol)
	-  웹에서 데이터를 주고받는 서버-클라이언트 모델의 프로토콜

	구조
	1. 시작 줄('start-line')
	- 실행되어야 할 요청, 또는 요청 수행에 대한 성공 또는 실패가 기록.
	- 항상 한 줄로 끝남
	2. HTTP 헤더
	- 요청에 대한 설명, 혹은 메시지 본문에 대한 설명
	3. 빈 줄('empty line')
	- 요청에 대한 모든 메타 정보가 전송되었음을 알림
	4. 본문(body )
	- 요청과 관련된 내용(HTML 폼 콘텐츠 등)이 옵션으로 들어가거나, 응답과 관련된 문서가 들어감
	- 본문의 존재 유무 및 크기는 첫 줄과 HTTP 헤더에 명시됨

##http 요청
	1. 시작줄
	-3가지 요소로 구성
		1) HTTP 메서드
			i. 영어 동사(GET, PUT,POST) 혹은 명사(HEAD, OPTIONS)를 사용해 서버가 수행해야 할 동작을 나타냄
			ii. GET은 리소스를 클라이언트로 가져다 달라는 뜻,
			POST는 데이터가 서버로 들어가야 함을 의미(리소스를 새로 만들거나 수정하기 위해, 또는 클라이언트로 돌려 보낼 임시 문서를 생성하기 위해)
		2) 요청 타겟
			i. 주로 URL, 또는 프로토콜, 포트, 도메인의 절대 경로로 나타낼 수도 있으며 이들은 요청 컨텍스트에 의해 특정
			ii. 요청 타겟 포맷은 HTTP 메소드에 따라 다름.
				1) 가장 일반적인 형식이고 'origin 형식'으로 알려진 절대 경로. 끝에 '?'와 쿼리 문자열이 따라옴. GET, POST, HEAD, OPTIONS 메서드와 함께 사용
				- POST / HTTP/1.1
				- GET /background.png HTTP/1.0
				- HEAD /test.html?query=alibaba HTTP/1.1
				- OPTIONS /anypage.html HTTP/1.0
				2) 'absolute 형식'으로 알려진 완전한 URL은 프록시에 연결하는 경우 대부분 GET과 함께 사용됩니다.
				-  GET http://developer.mozilla.org/ko/docs/Web/HTTP/Messages HTTP/1.1
				- 프록시 == 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템, 혹은 응용 프로그램
				3) 'authority 형식' : 도메인 이름 및 옵션 포트(':'가 앞에 붙음)로 이루어진 URL의 인증 컴포넌트
				-  HTTP 터널을 구축하는 경우에만 CONNECT와 함께 사용할 수 있습니다.
				-  CONNECT developer.mozilla.org:80 HTTP/1.1
				4) OPTIONS와 함께 별표('*') 하나로 서버 전체를 나타내는 'asterisk 형식'입니다. 
				- OPTIONS * HTTP/1.1
		3) TTP 버전
			-  응답 메시지에서 써야 할 HTTP 버전을 알려주는 역할
	2. 헤더
	-  HTTP 헤더의 기본 구조를 따름
	-  대소문자 구분 없는 문자열 다음에 콜론(':')이 붙으며, 그 뒤에 오는 값은 헤더에 따라 다름 
		1) General 헤더
			- Ex ) Via
			- 메시지 전체에 적용
		2) Request 헤더
			- Ex) User-Agent (en-US), Accept
			- 요청의 내용을 좀 더 구체화(Accept-Language),
			- 컨텍스를 제공하기도 하며(Referer)
			- 조건에 따른 제약 사항을 주기도 하면서(If-None) 요청 내용을 수정
		3) Representation 헤더
		- Ex) Content-Type(메시지 데이터의 원래 형식과 적용된 인코딩을 설명)
		- 메시지에 본문이 있는 경우에만 존재
	3. 본문(Body)
	- 요청의 마지막 부분에 들어감
	- 모든 요청에 들어가지는 않음(GET, HEAD, DELETE , OPTIONS처럼 리소스를 가져오는 요청은 보통 본문 필요 없음)
	- 일부 요청은 업데이트를 하기 위해 서버에 데이터를 전송 (보통 POST 요청일 경우)
		1) 단일 리소스 본문(single-resource body)
			- 헤더 두 개(Content-Type와 Content-Length)로 정의된 단일 파일로 구성
		2) 다중 리소스 본문
			- 각각 서로 다른 정보를 담고 있는 멀티파트 본문으로 구성
##http 응답
	1. 상태줄
	-3가지 요소로 구성
			1) 프로토콜 버전
			- 보통 HTTP/1.1
			2) 상태 코드
			- 요청의 성공 여부. 일반적인 상태 코드는 200, 404 혹은 302
			3) 상태 텍스트
			- 사람이 HTTP 메시지를 이해할 때 도움이 되는 상태 코드에 대한 짧고, 순전히 정보 제공 목적
	Ex)  HTTP/1.1 404 Not Found. 
	
	2. 헤더
	-  HTTP 헤더의 기본 구조를 따름(요청에서 사용한 헤더와 구조가 동일)
		1) General 헤더
			- Ex ) Via
			- 메시지 전체에 적용
		2) Response 헤더
		- Ex) Vary, Accept-Ranges
		- 상태 줄에 포함되지 않은 서버에 대한 추가 정보를 제공
		3) Representation 헤더
		- Ex) Content-Type(메시지 데이터의 원래 형식과 적용된 인코딩을 설명)
		- 메시지에 본문이 있는 경우에만 존재

	3. 본문(Body)
	- 응답의 마지막 부분에 들어감
	- 모든 요청에 들어가지는 않음(요청에 충분히 응답하는 201 Created, 204 **No Content**과 같은 상태 코드를 가진 응답은 보통 본문 필요 없음)
		1) 단일 리소스 본문(single-resource body)
			- 헤더 두 개(Content-Type와 Content-Length)로 정의된 길이가 알려진 하나의 파일로 구성
			- Transfer-Encoding가 chunked로 설정된 청크로 나뉘어 인코딩되는 길이를 모르는 하나의 파일로 구성
		2) 다중 리소스 본문
			- 각각 서로 다른 정보를 담고 있는 멀티파트 본문으로 구성
			- 단일 리소스 본문에 비해 보기 힘듦.