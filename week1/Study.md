# 목차

- **네트워크에 대한 이해** 
    - TCP/IP 의 동작 이해
    - 3-Hand Shaking 에 대한 이해
- **URL 구조 파악** 
- **개발자 도구 정보 파악**
- **서버와 클라이언트에 대한 이해** 
- **HTTP 요청, 응답 메시지에 대한 이해** 

# 네트워크에 대한 이해

**인터넷망에서 컴퓨터들을 어떻게 통신할까?**

클라이언트와 서버가 바로 옆에 있는 경우 간단하게 직접 케이블을 연결해서 메시지를 보내면 통신이 됩니다.

하지만 클라이언트와 서버 사이에 인터넷망이 중간에 존재한다면 어떻게 해야할까?

중간 노드에 속하는 수 많은 서버를 지나쳐 원하는 목적지 서버에 메시지가 도착해야하는데, 이렇게 하기 위해서는 어떤 규칙으로 목적지 서버에 도착하는지 정해놓은 **`IP 프로토콜`** 이라는 것을 알아야 합니다.

### TCP/IP 의 동작 이해

**📌 TCP/IP (Transmission Control Protocol / Internet Protocol)**

- 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜입니다.
- 송신자가 수신자에게 IP 주소를 사용하여 데이터를 전달하고 그 데이터가 제대로 갔는지에 대한 이야기를 하는 것입니다.

**📌 TCP/IP 계층 구조**

4계층이 존재합니다.

1. 응용 계층(어플리케이션 계층) - HTTP, FTP, SSH, SMTP 등
2. 전송 계층 - TCP, UDP, RTCP
3. 인터넷 계층 - IP, ICMP, ARP, RARP 등
4. 네트워크 액세스 계층(네트워크 인터페이스 계층) - LAN 드라이버, LAN 장비 

**📌 TCP/IP 쉽게 이해하기**

- IP 주소는 인터넷 상의 기기를 유일하게 식별하기 위한 번호입니다. 우리가 우편을 보낼 때 정확한 주소가 필요한 것처럼, 데이터 패킷이 올바른 목적지에 도달하도록 돕습니다.
- 하지만 데이터가 단말기 간에 올바른 순서로 전송된다는 보장이 없기 때문에, 종단간(End-to-End ; 단말기 간)에 오류 없이, 올바른 순서로 데이터가 전송되도록 관리하는 프로토콜인 TCP를 사용하여 이를 해결합니다.

### 3-Hand Shaking 에 대한 이해

**📌 TCP 3-way-handsahek(가상 연결)**

- 우선 TCP 는 가상 회선 연결(Virtual Circuit Connection) 형태의 서비스를 제공합니다.

- SYN (SYNchronize) : 접속 요청
- ACK (ACKnowledge) : 요청 수락
1. 클라이언트에서 먼저 SYN 메시지를 서버에게 요청합니다. 이는 서버에게 접속 허락을 구하는 것입니다.
2. 서버는 접속을 수락하고 응답으로 ACK 메시지를 클라이언트에게 전송합니다. 이때 서버의 접속을 요구하는 SYN 메시지와 함께 전송합니다.
3. 클라이언트가 접속을 수락하면 응답으로 서버에게 ACK 메시지를 전송합니다.
4. 연결이 되면 데이터 전송을 시작합니다.

**📌 데이터 전달 보증**

- 송신 측에서 데이터를 전송하면, 수신 측은 이를 확인하는 ACK 메시지를 송신측으로 전송합니다.
- ACK 메시지는 송신 측에게 “데이터가 정확하게 전송되었음” 을 알려주는 메시지 입니다.
- 송신 측이 ACK 를 받지 못하면, 데이터가 유실되었을 가능성이 있으므로 다시 전송을 시도합니다.

**📌 순서 보장**

1. 송신 측에서 데이터를 여러 세그먼트로 나누고, 각 세그먼트에 시퀀스 번호를 부여합니다. 이 세그먼트들은 TCP헤더가 추가된 후, IP 패킷으로 캡슐화되어 수신 측에 전달됩니다.
2. 수신 측에서는 IP 패킷을 수신하고, TCP 헤더의 정보를 바탕으로 세그먼트들을 올바른 순서로 재정렬합니다. 이렇게 해서 데이터를 원래의 순서대로 재조립합니다.
3. 데이터 전송 과정 중 유실 또는 손상된 세그먼트가 발견될 경우, 수신 측은 송신 측에 해당 세그먼트의 재전송을 요청합니다. 이러한 요청은 TCP 헤더 내의 확인응답(ACK)과 시퀀스 번호를 통해 이루어집니다.
4. 송신 측은 재전송 요청을 받으면 해당 세그먼트를 다시 TCP 헤더와 함께 IP 패킷으로 캡슐화 하여 재전송합니다.

<aside>
💡 **참고
세그먼트(Segment) :** TCP 계층에서 처리하는 데이터 단위로, TCP 헤더가 추가되어, 데이터의 전송을 관리합니다. 세그먼트는 데이터의 순서, 재전송, 흐름 제어 등을 관리합니다.

**패킷(Packet) :** IP 계층에서 처리하는 데이터 단위로, IP 헤더가 추가되어, 데이터가 올바른 목적지까지 어떻게 도달해야 하는지에 대한 정보를 담고 있습니다. 패킷은 네트워크를 통해 전송되는 데이터의 ‘봉투’ 역할을 합니다. 

**패킷의 구조 : 헤더(Header)**와 **페이로드(Payload)**로 구성됩니다. **헤더는 출발지 / 목적지 IP 주소, 시퀀스 번호 등 데이터가 올바르게 전송되고 처리될 수 있도록 하는 데 필요한 모든 메타데이터를 제공**하고, **페이로드는 사용자가 실제로 전송하고자 하는 데이터**를 담고 있습니다.

</aside>

<aside>
💡 알아두면 좋을 프로토콜 **UDP : User Datagram Protocol : 사용자 데이터그램 프로토콜

tcp는 전송해야할 정보도 많고, 3handShake때문에 전송속도가 느린 반면  UDP는 이러한 절차가 없기 때문에 상대적으로 전송속도가 빠르다. 따라서 대용량 파일을 전송할 때 주로 사용된다.

- TCP 3HandShake X
- 데이터 전달 보증 X
- 순서 보장 X**

</aside>

# URL 구조 파악

**📌 URI (Uniform Resource Identifier ; 통합 자원 식별자)**

- 인터넷 상의 자원을 식별하기 위한 문자열의 구조입니다.
- 모든 URL 은 URI 이지만, 모든 URI 가 URL은 아닙니다.

**📌 URL (Uniform Resource Locator ; 통합 자원 위치지정자)**

- 인터넷 상의 자원이 실제로 어디에 위치해 있는지를 나타내기 위한 구체적인 URI의 형태입니다.
- URL은 자원의 위치를 가리키며, 해당 자원을 얻기 위해 필요한 모든 정보를 담고 있습니다.
- 예시 : [`http://www.example.com/index.html`](http://www.example.com/index.html) (웹 서버 상의 특정 페이지를 가리키는 URL)

<aside>
💡 **정리
URI 는 자원을 식별하는 더 넓은 개념이고, URL은 그 자원의 실제 위치를 나타내는 URI의 특정한 형태.**

</aside>

**📌 쿼리(Query)**

- 쿼리 스트링은 URI의 일부로, 웹 서버에 제공되는 추가적인 정보를 포함합니다.
- 일반적으로 ‘?’ 문자 뒤에 위치하며, 키-값 쌍의 형태로 정보를 전달합니다.
- 웹 페이지에 데이터를 전달하거나, 서버에 특정 조작을 요청하는 데 사용됩니다.
- 예시
    - `**http://www.example.com/search?query=keyword**`
    - 여기서 `**query=keyword**` 가 쿼리 스트링입니다.
    - 이는 웹 서버에 ‘keyword’ 라는 문자열을 전달합니다.

**📌 프래그먼트 (Fragment)**

- URI의 마지막 부분에 위치하며, ‘#’ 문자로 시작합니다.
- 웹 페이지 내의 특정 섹션 또는 위치를 가리키는 데 사용됩니다.
- 프래그먼트는 클라이언트 측에서만 해석되며, 웹 서버로 전송되지 않습니다.
- 잘 사용하지 않습니다.
- 예시
    - `http://www.example.com/index.html#section2`

# 서버와 클라이언트에 대한 이해

**📌 클라이언트(Client)**

> 서버로부터 서비스나 데이터를 **요청**하는 컴퓨터
> 

클라이언트는 서버에서 받은 서비스를 사용하는 **사용자**로, 크게 **장치 또는 프로그램**이 될 수 있습니다.

클라이언트 장치는 최종 사용자가 웹에 접속하는데 사용하는 시스템으로 **데스크톱**, **노트북**, **스마트폰**, **태블릿** 등을 예시로 들 수 있습니다.

클라이언트 프로그램은 사용자가 웹을 통해 요청할 수 있게 해주는 프로그램으로 **크롬 같은 웹 브라우저**를 예로 들 수 있습니다.

**📌 서버(Server)**

> 데이터를 포함하거나 네트워크의 다른 컴퓨터에서 액세스 하는 기능을 **제공**하는 컴퓨터
> 

서버는 일반적으로 **클라이언트의 요청에 대해 응답해주는 시스템**으로, 간단하게 무언가를 제공해 주는 입장이라고 생각하면 됩니다.

우리가 컴퓨터를 할 때 일반적으로 웹 브라우저를 통해 정보를 볼 수 있는데 이것은 서버로 부터 정보를 받아 우리가 볼 수 있는 것입니다.

**📌 클라이언트 패킷 전달**

클라이언트에서 패킷을 규칙에 맞게 만들어 전송하게 되면, 전송된 패킷을 인터넷망의 노드들에서 해석해가면서 도착지 IP주소인 200.200.200.2에 도착하게 된다.

**📌 서버 패킷 전달**

서버도 클라이언트와 마찬가지로 패킷에 새로운 메시지와 여러 정보들을 넣고 전달하게 된다.

# **HTTP 요청, 응답 메시지에 대한 이해**

HTTP 요청으로 메시지를 보내고 싶거나 혹은 HTTP 응답을 받고 싶을 때, HTTP 메시지의 구조가 어떻게 구성되어 있는지 알아야 합니다.

- **HTTP Header**
    - **HTTP 전송에 필요한** 메시지 바디의 크기, 압축, 인증, 요청 클라이언트 정보, 서버 애플리케이션 정보, 캐시 관리 정보 등 **모든 부가 정보가 들어가 있습니다.**
- **HTTP Message Body**
    - **실제로 보내고자 하는 콘텐츠(내용)**이 들어가 있습니다.

**📌 HTTP 요청 메시지**

- start-line

start-line 에는 요청이나 응답의 상태를 나타내고, 항상 첫 번쨰 줄에 위치합니다.

http method (GET, POST 등) 와 Request target (요청 대상), HTTP version 세 가지 부분으로 구성되어 있습니다.

```jsx
**GET** /test.html HTTP/1.1
[HTTP Method] / [Request target] / [HTTP version]

[Example]
	GET/search?q=hello&hl=ko HTTP/1.1 -> start-line
	Host:www.google.com -> header
```

- HTTP Method
    - GET, POST, PUT, DELETE 등이 존재하며, 서버가 수행해야 할 동작을 지정합니다.
    - **GET**
        - GET 은 **보내고자 하는 데이터를 URL 후미에 ? 와 함께 쿼리 파라미터를 붙여서 전송**합니다.
        
        > **쿼리 파라미터란?**
        Key와 value로 이루어져 있는 문자열로, key=value의 형태로 표현한다.
        Get요청으로 쿼리를 전달하고 싶다면
        www.goooogle.com/main?name=likelion
        이런식으로 원하는 url뒤에 “?” 를 추가하고 그 이후에 적어주면 된다.
        > 
        - **URL에 보내고자 하는 내용이 전부 노출 되기 떄문에, 주로 조회, 검색 기능에 사용**된다는 점이 특징입니다.
    - **POST**
        - POST 는 GET 과 달리 **보내고자 하는 데이터를 메시지 바디에 포함시켜서 전송**합니다.
        - 메시지 바디에 포함시켜 데이터를 전송하여 데이터가 URL 상으로 노출되지 않기 때문에 GET 방식보다는 비교적 보안성이 높습니다.
        - 이에 따라 **주로 서버에 데이터를 제출하고자 할 때 POST 방식을 사용**합니다.
    - PUT
        - 리소스를 생성하거나, 이미 존재하는 경우 해당 리소스를 대체합니다.
    - PATCH
        - 리소스의 부분적인 수정을 위해 사용됩니다.
    
    > 여기서 말하는 리소스는 정보나 데이터를 말합니다.
    > 
    
    > **PUT 과 PATCH 의 차이점**
    PUT은 리소스 전체를 대체하지만, PATCH는 변경하고자 하는 부분만을 전송합니다.
    > 
    - **DELETE**
        - 리소스를 삭제하는데 사용됩니다.
        - DELETE 요청이 성공하게 되면, 삭제된 리소스는 더 이상 접근할 수 없게 됩니다.
- **reqeust-target - /test.html**
    
    ```jsx
    /absolute-pate[?query]
    /절대경로[?쿼리]
    ```
    
    - **HTTP Request 가 전송되는 목표 주소**입니다.
    - 보통 절대 경로로 ‘/’ 로 시작하고 쿼리를 합치게 됩니다.
- **HTTP-version (HTTP 버전)**
    - 말 그대로 HTTP 버전을 이야기 합니다.
    - 버전에 따라 Request 메시지 구조나 데이터가 다를 수 있기 때문에 버전을 명시합니다.

**📌 HTTP 응답 메시지**

- **start-line :status-line**

```jsx
HTTP/1.1 200 OK 
------상태라인------
Date: Fri, 13 Apr 2024 12:34:56 GMT
Server: Apache/2.4.1 (Unix)
Content-Type: text/html; charset=UTF-8
Content-Length: 1234
-----응답헤더-----

<html>
<head>
  <title>예시 페이지</title>
</head>
<body>
  <h1>안녕하세요!</h1>
  <p>이것은 HTTP 응답 메시지의 본문 예시입니다.</p>
</body>
</html>
-----메시지 본문-----
```

- 상태 라인(Status Line)
    - `HTTP/1.1 200 OK`는 이 응답이 HTTP 1.1 프로토콜을 사용(**버전)**하며, **상태 코드**가 200(요청이 성공적으로 처리됨)임을 나타냅니다. "OK"는 **상태 코드의 짧은 설명**입니다.
- status-code (HTTP 상태 코드)
    
    클라이언트가 보낸 요청이 성공했는지 실패했는지 나타내는 상태이다.
    
    - 1xx (Informational): 요청이 수신되어 처리중
    - **2xx (Successful): 요청 정상 처리**
    - **3xx (Redirection): 요청을 완료하려면 추가 행동이 필요**
    - **4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음**
    - **5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함**
- **응답 헤더(Response Headers)**
    - 여기에는 **응답에 대한 추가 정보**가 포함됩니다. 예를 들어, `Date`는 응답이 생성된 날짜와 시간을 나타내며, `Server`는 응답을 생성한 웹 서버의 소프트웨어에 대한 정보를 제공합니다. `Content-Type`은 메시지 본문의 미디어 유형을 나타내고, `Content-Length`는 본문의 길이(바이트 단위)를 나타냅니다.
- **메시지 본문(Message Body)**
    - 응답의 **실제 내용**을 포함하며, 여기서는 HTML 문서가 예시로 사용되었습니다. 본문의 내용은 `Content-Type` 헤더에 지정된 미디어 유형에 따라 달라집니다.