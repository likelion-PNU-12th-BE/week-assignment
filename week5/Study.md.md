# 정규화
### 📕 정규화의 목적과 중요성 알아보기
:
정규화는 데이터베이스의 설계를 개선하는 과정입니다.
DB 설계 개선은 중복을 최소화하거나, 데이터 무결성 및 일관성을 유지시키는 방식으로 이루어집니다.
DB 설계 개선을 통하여 저장 공간을 줄이거나, 데이터 정확성과 신뢰성을 높일 수 있습니다.

### 📕 정규화의 종류 알아보기 (1NF, 2NF, 3NF, BCNF)
:
1. 제1정규화(1NF)
   모든 필드의 값이 원자값을 가지며, 각 필드마다 고유한 값을 가지도록 하는 정규화입니다.
   (원자값 = 한 필드에 단일 요소)
2. 제2정규화(2NF)
   1NF를 만족하며, 모든 비주요 속성이 기본키에 완전 함수적 종속을 만족시키는 정규화입니다.
   (비주요 속성 : 기본키나 후보키에 속하지 않는 모든 속성)
3. 제3정규화(3NF)
   2NF를 만족하며, 비주요 속성이 기본키에만 종속되어야 하고, 다른 비주요 속성에 종속되지 않도록 하는 정규화입니다
4. 보이스-코드 정규화(BCNF)
   3NF를 만족하며, 모든 결정자가 후보키로 만드는 정규화입니다.
   
### 📕 반정규화 알아보기
:
반정규화는 정규화된 데이터베이스에서 성능 향상을 위해 의도적으로 중복을 허용하거나 데이터를 합치는 과정입니다.
반정규화를 통해서 쿼리의 복잡도를 줄이고 성능을 개선하기 위해 사용되지만, 데이터 무결성 관리에 더 많은 주의가 필요합니다.

### 📕 외래키(Foreign Key;FK)와 연관 관계

📕 외래키(FK) 의 정의와 역할
:
- 정의 
  외래키는 한 테이블에서 다른 테이블의 기본키(Primary Key;PK)를 참조하는 필드를 말합니다.
- 역할
  (1) 데이터 무결성 유지
  외래키는 참조 무결성을 보장하여 데이터의 일관성을 유지합니다
  예를 들어, 외래키가 참조하는 값이 존재하지 않는 경우 데이터 삽입이나 업데이트가 제한됩니다.
  (2) 관계 설정
  외래키는 두 테이블 사이의 관계를 설정합니다.
  이를 통해 테이블 간의 데이터 연관성을 정의하고, Join연산 등을 통해 관련 데이터를 쉽게 조회할 수 있습니다.
  (3) 제약 조건
  FK는 데이터의 유효성을 검증하는 제약 조건으로 작용합니다.
  예를 들어, 부모 테이블의 행이 삭제되면 자식 테이블의 관련 행들도 삭제(CASCADE)되거나, 외래키 값이 NULL로 설정(SET NULL)되는 등의 동작을 정의할 수 있습니다.

📕 외래키 설정 방법 및 주의점
:
- 외래키 설정방법
  (1) 테이블 생성 시 외래키 생성
  ```sql
    CREATE TABLE 자식테이블 (
    id INT PRIMARY KEY,
    부모테이블_id INT,
    FOREIGN KEY (부모테이블_id) REFERENCES 부모테이블(id)
    );
  ```
  (2) 기존 테이블에 외래키 추가
```sql
  ALTER TABLE 자식테이블
  ADD CONSTRAINT fk_부모테이블
  FOREIGN KEY (부모테이블_id)
  REFERENCES 부모테이블(id);
  ```

- 주의점
  (1) 데이터 무결성 유지해야 함
  외래키가 참조하는 값이 부모 테이블에 존재하는 지 확인해야 합니다.
  부모 테이블의 기본 키 값이 변경되거나 삭제될 때 자식 테이블의 외래키 값도 적절히 처리되어야 합니다.
  (2) 참조 무결성 제약 조건
  외래키 제약 조건을 설정할 때, CASCADE, SET NULL, RESTRICT 등의 옵션을 적절히 설정하여 데이터 무결성을 유지해야 합니다.

  - **CASCADE:** 
    부모 테이블의 행이 삭제되거나 업데이트될 때, 자식 테이블의 관련 행들도 함께 삭제되거나 업데이트됩니다.
    ```sql
    -- 테이블 생성 시 외래키에 CASCADE 옵션 설정
CREATE TABLE ChildTable (
    id INT PRIMARY KEY,
    ParentTable_id INT,
    FOREIGN KEY (ParentTable_id) REFERENCES ParentTable(id) ON DELETE CASCADE ON UPDATE CASCADE
);

-- 기존 테이블에 외래키 추가 시 CASCADE 옵션 설정
ALTER TABLE ChildTable
ADD CONSTRAINT fk_ParentTable
FOREIGN KEY (ParentTable_id) REFERENCES ParentTable(id)
ON DELETE CASCADE
ON UPDATE CASCADE;

```
- **SET NULL:** 
   부모 테이블의 행이 삭제되거나 업데이트될 때, 자식 테이블의 외래키 값을 NULL로 설정합니다.
   ```sql
   -- 테이블 생성 시 외래키에 SET NULL 옵션 설정
CREATE TABLE ChildTable (
    id INT PRIMARY KEY,
    ParentTable_id INT,
    FOREIGN KEY (ParentTable_id) REFERENCES ParentTable(id) ON DELETE SET NULL ON UPDATE SET NULL
);

-- 기존 테이블에 외래키 추가 시 SET NULL 옵션 설정
ALTER TABLE ChildTable
ADD CONSTRAINT fk_ParentTable
FOREIGN KEY (ParentTable_id) REFERENCES ParentTable(id)
ON DELETE SET NULL
ON UPDATE SET NULL;
```
 - **RESTRICT:** 
   부모 테이블의 행이 삭제되거나 업데이트될 때, 자식 테이블의 관련 행이 존재하면 해당 작업을 제한합니다.(MySQL에서는 RESTRICT를 디폴트로 동작합니다.)
- 
📕 일대일(1 : 1), 다대일(N : 1), 다대다(N : M) 관계의 이해
1. 일대일 관계 : 하나의 레코드가 다른 테이블의 한개의 레코드와 연결
2. 다대일 관계 : 하나의 레코드가 다른 테이블의 다수의 레코드와 연결
3. 다대다 관계 : 여러개 레코드가 다른 테이블의 다수의 레코드와 연결
### 📕 CRUD와 조인

📕 등록(Create), 조회(Read), 수정(Update), 삭제(Delete)의 이해

- Create : 데이터 추가
- Read : 데이터 검색,조회
- Update : 기존 데이터 수정
- Delete : 데이터 삭제

📕 INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN의 이해

- Inner Join : 두 테이블의 교집합을 반환
- Left Join : 왼쪽 테이블의 모든 데이터와 오른쪽 테이블과 일치하는 데이터 반환
- Right Join : 오른쪽 테이블의 모든 데이터와 왼쪽 테이블과 일치하는 데이터 반환
- Full Join : 두 테이블의 합집합 반환, 양쪽 테이블에서 일치하지 않는 행도 포함됨

# 추가 학습

1. 무결성 (Data integrity,완전성)
   정의 : DB 내에 저장되는 '데이터 값들이' 일관성, 유효성, 정확성, 안정성을 유지하는 상태를 의미한다.
   DB의 무결성을 유지하기위하여 연산에 제한을 가한다.
   ('제약 조건' = 만족해야하는 조건 / 무결성 제약 조건 = 무결성 만족하기위해 필요한 조건)
   
   무결성에는 4가지 종류가 존재한다.
   
   (1) 개체 무결성(Entity integrity)
   : PK 무결성 
   (1') 개체 무결성 의의
   개체 무결성은 테이블 내의 각 행이 고유하게 식별될 수 있도록 보장합니다.
   (1'') 개체 무결성 제약 조건
   모든 테이블이 기본키(PK)를 가져야 하고, 기본 키로 선택된 열은 고유하고, null을 허용하지 않는다
   
   (2) 참조 무결성(Referential integrity)
   : FK 무결성 
   (2') 참조 무결성 의의
   : FK를 통해 부모 테이블과 자식 테이블 간의 일관성을 보장합니다.
   (2'') 참조 무결성 제약 조건
   : FK = NULL or 참조 테이블의 PK
   
   (3) 도메인 무결성
   : 필드 무결성
   (3') 도메인 무결성 의의
   : 필드에 맞는 데이터가 입력되었는지, 데이터의 정확성 보장해준다.
   (3'') 도메인 무결성 제약 조건
   : 필드마다 데이터 타입, 제약 조건, 기본 값으로 구현된다.
   
   (4) NULL 무결성/의의
   : 특정 열이 null 값을 가질 수 있는지 여부 제어
   (4') NOT NULL로 제어
   
> 무결성 = 완전히 안정적인 상태
> 무결한 대상에 따라 무결성 종류가 달라짐
> 무결성 제약 조건 = 무결하기위한 필요조건
> 무결성 제약 조건은 생성 시 설정 코드로 구현할 수 있다. 
   
2. 함수적 종속(Fuctional Dependency)
   함수 종속성 하나의 릴레이션 내이 속성 X집합과 속성 Y집합이 존재할 때, X 값에 대해 Y의 값을 오직 하나를 유일하게 결정할 수 있는 경우 "Y는 X에 함수 종속적(X에따라 Y가 결정되므로)"
   (ex)
   학번/이름 ; 학번으로 이름 유일하게 하나 매핑 but 이름으로 학번을 유일하게 매핑할 수 없다.
   학번->이름 / 이름은 학번에 함수 종속이다.
   
   함수 종속성은 DB 설계에 중요하다.
   함수 종속성을 이용하면 데이터의 중복성과 비일관성을 줄이고, 데이터의 무결성과 효율성을 높일 수 있다.
   함수 종속성을 기반으로 테이블을 정규화하는 과정을 통해 데이터베이스의 품질을 향상시킬 수 있다.
   
   완전 함수적 종속
   한 테이블에서 어떤 속성이 다른 속성의 부분집합에 의해서만 결정되지않고, 전체 속성에 의해서만 결정될 때를 말한다.
   예를 들어, 학생 테이블에서 학번, 이름, 학과를 속성으로 가지고 있다고 가정해 봅시다. 이때, 학번은 이름, 전공, 학과의 부분집합인 이름에 의해서만 결정되지 않습니다. 즉, 이름이 같은 학생이 여러 명 있을 수 있기 때문입니다. 따라서 학번은 이름, 전공, 학과의 전체 속성에 의해서만 결정됩니다
   이렇게 완전 함수적 종속을 만족하는 속성을 기본키로 설정하면 데이터의 중복과 불일치를 줄일 수 있다.
   
   부분 함수적 종속
   부분 함수적 종속이란 한 릴레이션의 속성들이 다른 속성들의 일부에만 의존하는 경우를 말한다.
   예를 들어, 학생 릴레이션에서 학번, 이름, 학과, 학과장을 속성으로 가진다고 하면, 학과장은 학과에만 의존하고 학번과 이름에는 의존하지 않습니다. 이런 경우, 학과장은 학과에 부분 함수적 종속되어 있다고 할 수 있습니다.
   부분 함수적 종속은 릴레이션을 정규화하는 과정에서 제거해야 하는 이상 현상을 발생시킬 수 있습니다.
   예를 들어, 아래의 학생 릴레이션에서 학과가 변경되면, 그에 따라 학과장도 변경되어야 하는데, 이를 놓치면 데이터의 불일치가 발생할 수 있습니다. 따라서, 부분 함수적 종속을 제거하기 위해 릴레이션을 분해하는 것이 필요할 수 있습니다. 이것이 바로 제 2 정규형의 목적입니다.

